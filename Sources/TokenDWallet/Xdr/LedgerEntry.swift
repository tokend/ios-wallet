// Automatically generated by xdrgen
// DO NOT EDIT or your changes may be overwritten

import Foundation

// === xdr source ============================================================

//  struct LedgerEntry
//  {
//      uint32 lastModifiedLedgerSeq; // ledger the LedgerEntry was last changed
//  
//      union switch (LedgerEntryType type)
//      {
//      case ACCOUNT:
//          AccountEntry account;
//      case SIGNER:
//          SignerEntry signer;
//      case FEE:
//          FeeEntry feeState;
//      case BALANCE:
//          BalanceEntry balance;
//      case ASSET:
//          AssetEntry asset;
//      case REFERENCE_ENTRY:
//          ReferenceEntry reference;
//      case STATISTICS:
//          StatisticsEntry stats;
//      case ACCOUNT_LIMITS:
//          AccountLimitsEntry accountLimits;
//  	case ASSET_PAIR: 
//  		AssetPairEntry assetPair;
//  	case OFFER_ENTRY:
//  		OfferEntry offer;
//  	case REVIEWABLE_REQUEST:
//  		ReviewableRequestEntry reviewableRequest;
//  	case EXTERNAL_SYSTEM_ACCOUNT_ID:
//  		ExternalSystemAccountID externalSystemAccountID;
//  	case SALE:
//  		SaleEntry sale;
//  	case KEY_VALUE:
//  	    KeyValueEntry keyValue;
//  	case ACCOUNT_KYC:
//          AccountKYCEntry accountKYC;
//      case EXTERNAL_SYSTEM_ACCOUNT_ID_POOL_ENTRY:
//          ExternalSystemAccountIDPoolEntry externalSystemAccountIDPoolEntry;
//      case LIMITS_V2:
//          LimitsV2Entry limitsV2;
//      case STATISTICS_V2:
//          StatisticsV2Entry statisticsV2;
//      case PENDING_STATISTICS:
//          PendingStatisticsEntry pendingStatistics;
//      case CONTRACT:
//          ContractEntry contract;
//      case ATOMIC_SWAP_ASK:
//          AtomicSwapAskEntry atomicSwapAsk;
//      case ACCOUNT_ROLE:
//          AccountRoleEntry accountRole;
//      case ACCOUNT_RULE:
//          AccountRuleEntry accountRule;
//      case SIGNER_RULE:
//          SignerRuleEntry signerRule;
//      case SIGNER_ROLE:
//          SignerRoleEntry signerRole;
//      case LICENSE:
//          LicenseEntry license;
//      case STAMP:
//          StampEntry stamp;
//      case POLL:
//          PollEntry poll;
//      case VOTE:
//          VoteEntry vote;
//      case ACCOUNT_SPECIFIC_RULE:
//          AccountSpecificRuleEntry accountSpecificRule;
//      case SWAP:
//          SwapEntry swap;
//      }
//      data;
//  
//      // reserved for future use
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//  };

//  ===========================================================================
public struct LedgerEntry: XDRCodable {
  public var lastModifiedLedgerSeq: Uint32
  public var data: LedgerEntryData
  public var ext: LedgerEntryExt

  public init(
      lastModifiedLedgerSeq: Uint32,
      data: LedgerEntryData,
      ext: LedgerEntryExt) {

    self.lastModifiedLedgerSeq = lastModifiedLedgerSeq
    self.data = data
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.lastModifiedLedgerSeq.toXDR())
    xdr.append(self.data.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public init(xdrData: inout Data) throws {
    self.lastModifiedLedgerSeq = try Uint32(xdrData: &xdrData)
    self.data = try LedgerEntryData(xdrData: &xdrData)
    self.ext = try LedgerEntryExt(xdrData: &xdrData)
  }

  public enum LedgerEntryData: XDRDiscriminatedUnion {
    case account(AccountEntry)
    case signer(SignerEntry)
    case fee(FeeEntry)
    case balance(BalanceEntry)
    case asset(AssetEntry)
    case referenceEntry(ReferenceEntry)
    case statistics(StatisticsEntry)
    case accountLimits(AccountLimitsEntry)
    case assetPair(AssetPairEntry)
    case offerEntry(OfferEntry)
    case reviewableRequest(ReviewableRequestEntry)
    case externalSystemAccountId(ExternalSystemAccountID)
    case sale(SaleEntry)
    case keyValue(KeyValueEntry)
    case accountKyc(AccountKYCEntry)
    case externalSystemAccountIdPoolEntry(ExternalSystemAccountIDPoolEntry)
    case limitsV2(LimitsV2Entry)
    case statisticsV2(StatisticsV2Entry)
    case pendingStatistics(PendingStatisticsEntry)
    case contract(ContractEntry)
    case atomicSwapAsk(AtomicSwapAskEntry)
    case accountRole(AccountRoleEntry)
    case accountRule(AccountRuleEntry)
    case signerRule(SignerRuleEntry)
    case signerRole(SignerRoleEntry)
    case license(LicenseEntry)
    case stamp(StampEntry)
    case poll(PollEntry)
    case vote(VoteEntry)
    case accountSpecificRule(AccountSpecificRuleEntry)
    case swap(SwapEntry)

    public var discriminant: Int32 {
      switch self {
      case .account: return LedgerEntryType.account.rawValue
      case .signer: return LedgerEntryType.signer.rawValue
      case .fee: return LedgerEntryType.fee.rawValue
      case .balance: return LedgerEntryType.balance.rawValue
      case .asset: return LedgerEntryType.asset.rawValue
      case .referenceEntry: return LedgerEntryType.referenceEntry.rawValue
      case .statistics: return LedgerEntryType.statistics.rawValue
      case .accountLimits: return LedgerEntryType.accountLimits.rawValue
      case .assetPair: return LedgerEntryType.assetPair.rawValue
      case .offerEntry: return LedgerEntryType.offerEntry.rawValue
      case .reviewableRequest: return LedgerEntryType.reviewableRequest.rawValue
      case .externalSystemAccountId: return LedgerEntryType.externalSystemAccountId.rawValue
      case .sale: return LedgerEntryType.sale.rawValue
      case .keyValue: return LedgerEntryType.keyValue.rawValue
      case .accountKyc: return LedgerEntryType.accountKyc.rawValue
      case .externalSystemAccountIdPoolEntry: return LedgerEntryType.externalSystemAccountIdPoolEntry.rawValue
      case .limitsV2: return LedgerEntryType.limitsV2.rawValue
      case .statisticsV2: return LedgerEntryType.statisticsV2.rawValue
      case .pendingStatistics: return LedgerEntryType.pendingStatistics.rawValue
      case .contract: return LedgerEntryType.contract.rawValue
      case .atomicSwapAsk: return LedgerEntryType.atomicSwapAsk.rawValue
      case .accountRole: return LedgerEntryType.accountRole.rawValue
      case .accountRule: return LedgerEntryType.accountRule.rawValue
      case .signerRule: return LedgerEntryType.signerRule.rawValue
      case .signerRole: return LedgerEntryType.signerRole.rawValue
      case .license: return LedgerEntryType.license.rawValue
      case .stamp: return LedgerEntryType.stamp.rawValue
      case .poll: return LedgerEntryType.poll.rawValue
      case .vote: return LedgerEntryType.vote.rawValue
      case .accountSpecificRule: return LedgerEntryType.accountSpecificRule.rawValue
      case .swap: return LedgerEntryType.swap.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.discriminant.toXDR())

      switch self {
      case .account(let data): xdr.append(data.toXDR())
      case .signer(let data): xdr.append(data.toXDR())
      case .fee(let data): xdr.append(data.toXDR())
      case .balance(let data): xdr.append(data.toXDR())
      case .asset(let data): xdr.append(data.toXDR())
      case .referenceEntry(let data): xdr.append(data.toXDR())
      case .statistics(let data): xdr.append(data.toXDR())
      case .accountLimits(let data): xdr.append(data.toXDR())
      case .assetPair(let data): xdr.append(data.toXDR())
      case .offerEntry(let data): xdr.append(data.toXDR())
      case .reviewableRequest(let data): xdr.append(data.toXDR())
      case .externalSystemAccountId(let data): xdr.append(data.toXDR())
      case .sale(let data): xdr.append(data.toXDR())
      case .keyValue(let data): xdr.append(data.toXDR())
      case .accountKyc(let data): xdr.append(data.toXDR())
      case .externalSystemAccountIdPoolEntry(let data): xdr.append(data.toXDR())
      case .limitsV2(let data): xdr.append(data.toXDR())
      case .statisticsV2(let data): xdr.append(data.toXDR())
      case .pendingStatistics(let data): xdr.append(data.toXDR())
      case .contract(let data): xdr.append(data.toXDR())
      case .atomicSwapAsk(let data): xdr.append(data.toXDR())
      case .accountRole(let data): xdr.append(data.toXDR())
      case .accountRule(let data): xdr.append(data.toXDR())
      case .signerRule(let data): xdr.append(data.toXDR())
      case .signerRole(let data): xdr.append(data.toXDR())
      case .license(let data): xdr.append(data.toXDR())
      case .stamp(let data): xdr.append(data.toXDR())
      case .poll(let data): xdr.append(data.toXDR())
      case .vote(let data): xdr.append(data.toXDR())
      case .accountSpecificRule(let data): xdr.append(data.toXDR())
      case .swap(let data): xdr.append(data.toXDR())
      }

      return xdr
    }

    public init(xdrData: inout Data) throws {
      let discriminant = try Int32(xdrData: &xdrData)

      switch discriminant {
      case LedgerEntryType.account.rawValue:
        let data = try AccountEntry(xdrData: &xdrData)
        self = .account(data)
      case LedgerEntryType.signer.rawValue:
        let data = try SignerEntry(xdrData: &xdrData)
        self = .signer(data)
      case LedgerEntryType.fee.rawValue:
        let data = try FeeEntry(xdrData: &xdrData)
        self = .fee(data)
      case LedgerEntryType.balance.rawValue:
        let data = try BalanceEntry(xdrData: &xdrData)
        self = .balance(data)
      case LedgerEntryType.asset.rawValue:
        let data = try AssetEntry(xdrData: &xdrData)
        self = .asset(data)
      case LedgerEntryType.referenceEntry.rawValue:
        let data = try ReferenceEntry(xdrData: &xdrData)
        self = .referenceEntry(data)
      case LedgerEntryType.statistics.rawValue:
        let data = try StatisticsEntry(xdrData: &xdrData)
        self = .statistics(data)
      case LedgerEntryType.accountLimits.rawValue:
        let data = try AccountLimitsEntry(xdrData: &xdrData)
        self = .accountLimits(data)
      case LedgerEntryType.assetPair.rawValue:
        let data = try AssetPairEntry(xdrData: &xdrData)
        self = .assetPair(data)
      case LedgerEntryType.offerEntry.rawValue:
        let data = try OfferEntry(xdrData: &xdrData)
        self = .offerEntry(data)
      case LedgerEntryType.reviewableRequest.rawValue:
        let data = try ReviewableRequestEntry(xdrData: &xdrData)
        self = .reviewableRequest(data)
      case LedgerEntryType.externalSystemAccountId.rawValue:
        let data = try ExternalSystemAccountID(xdrData: &xdrData)
        self = .externalSystemAccountId(data)
      case LedgerEntryType.sale.rawValue:
        let data = try SaleEntry(xdrData: &xdrData)
        self = .sale(data)
      case LedgerEntryType.keyValue.rawValue:
        let data = try KeyValueEntry(xdrData: &xdrData)
        self = .keyValue(data)
      case LedgerEntryType.accountKyc.rawValue:
        let data = try AccountKYCEntry(xdrData: &xdrData)
        self = .accountKyc(data)
      case LedgerEntryType.externalSystemAccountIdPoolEntry.rawValue:
        let data = try ExternalSystemAccountIDPoolEntry(xdrData: &xdrData)
        self = .externalSystemAccountIdPoolEntry(data)
      case LedgerEntryType.limitsV2.rawValue:
        let data = try LimitsV2Entry(xdrData: &xdrData)
        self = .limitsV2(data)
      case LedgerEntryType.statisticsV2.rawValue:
        let data = try StatisticsV2Entry(xdrData: &xdrData)
        self = .statisticsV2(data)
      case LedgerEntryType.pendingStatistics.rawValue:
        let data = try PendingStatisticsEntry(xdrData: &xdrData)
        self = .pendingStatistics(data)
      case LedgerEntryType.contract.rawValue:
        let data = try ContractEntry(xdrData: &xdrData)
        self = .contract(data)
      case LedgerEntryType.atomicSwapAsk.rawValue:
        let data = try AtomicSwapAskEntry(xdrData: &xdrData)
        self = .atomicSwapAsk(data)
      case LedgerEntryType.accountRole.rawValue:
        let data = try AccountRoleEntry(xdrData: &xdrData)
        self = .accountRole(data)
      case LedgerEntryType.accountRule.rawValue:
        let data = try AccountRuleEntry(xdrData: &xdrData)
        self = .accountRule(data)
      case LedgerEntryType.signerRule.rawValue:
        let data = try SignerRuleEntry(xdrData: &xdrData)
        self = .signerRule(data)
      case LedgerEntryType.signerRole.rawValue:
        let data = try SignerRoleEntry(xdrData: &xdrData)
        self = .signerRole(data)
      case LedgerEntryType.license.rawValue:
        let data = try LicenseEntry(xdrData: &xdrData)
        self = .license(data)
      case LedgerEntryType.stamp.rawValue:
        let data = try StampEntry(xdrData: &xdrData)
        self = .stamp(data)
      case LedgerEntryType.poll.rawValue:
        let data = try PollEntry(xdrData: &xdrData)
        self = .poll(data)
      case LedgerEntryType.vote.rawValue:
        let data = try VoteEntry(xdrData: &xdrData)
        self = .vote(data)
      case LedgerEntryType.accountSpecificRule.rawValue:
        let data = try AccountSpecificRuleEntry(xdrData: &xdrData)
        self = .accountSpecificRule(data)
      case LedgerEntryType.swap.rawValue:
        let data = try SwapEntry(xdrData: &xdrData)
        self = .swap(data)
      default:
        throw XDRErrors.unknownEnumCase
      }
    }

  }
  public enum LedgerEntryExt: XDRDiscriminatedUnion {
    case emptyVersion()

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.discriminant.toXDR())

      switch self {
      case .emptyVersion(): xdr.append(Data())
      }

      return xdr
    }

    public init(xdrData: inout Data) throws {
      let discriminant = try Int32(xdrData: &xdrData)

      switch discriminant {
      case LedgerVersion.emptyVersion.rawValue: self = .emptyVersion()
      default:
        throw XDRErrors.unknownEnumCase
      }
    }

  }
}
