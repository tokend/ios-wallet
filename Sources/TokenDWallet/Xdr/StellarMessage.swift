// Automatically generated by xdrgen
// DO NOT EDIT or your changes may be overwritten

import Foundation

// === xdr source ============================================================

//  union StellarMessage switch (MessageType type)
//  {
//  case ERROR_MSG:
//      Error error;
//  case HELLO:
//      Hello hello;
//  case AUTH:
//      Auth auth;
//  case DONT_HAVE:
//      DontHave dontHave;
//  case GET_PEERS:
//      void;
//  case PEERS:
//      PeerAddress peers<>;
//  
//  case GET_TX_SET:
//      uint256 txSetHash;
//  case TX_SET:
//      TransactionSet txSet;
//  
//  case TRANSACTION:
//      TransactionEnvelope transaction;
//  
//  // SCP
//  case GET_SCP_QUORUMSET:
//      uint256 qSetHash;
//  case SCP_QUORUMSET:
//      SCPQuorumSet qSet;
//  case SCP_MESSAGE:
//      SCPEnvelope envelope;
//  case GET_SCP_STATE:
//      uint32 getSCPLedgerSeq; // ledger seq requested ; if 0, requests the latest
//  };

//  ===========================================================================
public enum StellarMessage: XDRDiscriminatedUnion {
  case errorMsg(Error)
  case hello(Hello)
  case auth(Auth)
  case dontHave(DontHave)
  case getPeers()
  case peers([PeerAddress])
  case getTxSet(Uint256)
  case txSet(TransactionSet)
  case transaction(TransactionEnvelope)
  case getScpQuorumset(Uint256)
  case scpQuorumset(SCPQuorumSet)
  case scpMessage(SCPEnvelope)
  case getScpState(Uint32)

  public var discriminant: Int32 {
    switch self {
    case .errorMsg: return MessageType.errorMsg.rawValue
    case .hello: return MessageType.hello.rawValue
    case .auth: return MessageType.auth.rawValue
    case .dontHave: return MessageType.dontHave.rawValue
    case .getPeers: return MessageType.getPeers.rawValue
    case .peers: return MessageType.peers.rawValue
    case .getTxSet: return MessageType.getTxSet.rawValue
    case .txSet: return MessageType.txSet.rawValue
    case .transaction: return MessageType.transaction.rawValue
    case .getScpQuorumset: return MessageType.getScpQuorumset.rawValue
    case .scpQuorumset: return MessageType.scpQuorumset.rawValue
    case .scpMessage: return MessageType.scpMessage.rawValue
    case .getScpState: return MessageType.getScpState.rawValue
    }
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.discriminant.toXDR())

    switch self {
    case .errorMsg(let data): xdr.append(data.toXDR())
    case .hello(let data): xdr.append(data.toXDR())
    case .auth(let data): xdr.append(data.toXDR())
    case .dontHave(let data): xdr.append(data.toXDR())
    case .getPeers(): xdr.append(Data())
    case .peers(let data): xdr.append(data.toXDR())
    case .getTxSet(let data): xdr.append(data.toXDR())
    case .txSet(let data): xdr.append(data.toXDR())
    case .transaction(let data): xdr.append(data.toXDR())
    case .getScpQuorumset(let data): xdr.append(data.toXDR())
    case .scpQuorumset(let data): xdr.append(data.toXDR())
    case .scpMessage(let data): xdr.append(data.toXDR())
    case .getScpState(let data): xdr.append(data.toXDR())
    }

    return xdr
  }

  public init(xdrData: inout Data) throws {
    let discriminant = try Int32(xdrData: &xdrData)

    switch discriminant {
    case MessageType.errorMsg.rawValue:
      let data = try Error(xdrData: &xdrData)
      self = .errorMsg(data)
    case MessageType.hello.rawValue:
      let data = try Hello(xdrData: &xdrData)
      self = .hello(data)
    case MessageType.auth.rawValue:
      let data = try Auth(xdrData: &xdrData)
      self = .auth(data)
    case MessageType.dontHave.rawValue:
      let data = try DontHave(xdrData: &xdrData)
      self = .dontHave(data)
    case MessageType.getPeers.rawValue: self = .getPeers()
    case MessageType.peers.rawValue:
      let lengthpeers = try Int32(xdrData: &xdrData)
      var data = [PeerAddress]()
      for _ in 1...lengthpeers {
        data.append(try PeerAddress(xdrData: &xdrData))
      }
      self = .peers(data)
    case MessageType.getTxSet.rawValue:
      let data = try Uint256(xdrData: &xdrData)
      self = .getTxSet(data)
    case MessageType.txSet.rawValue:
      let data = try TransactionSet(xdrData: &xdrData)
      self = .txSet(data)
    case MessageType.transaction.rawValue:
      let data = try TransactionEnvelope(xdrData: &xdrData)
      self = .transaction(data)
    case MessageType.getScpQuorumset.rawValue:
      let data = try Uint256(xdrData: &xdrData)
      self = .getScpQuorumset(data)
    case MessageType.scpQuorumset.rawValue:
      let data = try SCPQuorumSet(xdrData: &xdrData)
      self = .scpQuorumset(data)
    case MessageType.scpMessage.rawValue:
      let data = try SCPEnvelope(xdrData: &xdrData)
      self = .scpMessage(data)
    case MessageType.getScpState.rawValue:
      let data = try Uint32(xdrData: &xdrData)
      self = .getScpState(data)
    default:
      throw XDRErrors.unknownEnumCase
    }
  }
}
