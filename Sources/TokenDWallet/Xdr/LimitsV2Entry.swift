// Automatically generated by xdrgen
// DO NOT EDIT or your changes may be overwritten

import Foundation

// === xdr source ============================================================

//  //: `LimitsV2Entry` is used in the system configuration to set limits (daily, weekly, montly, annual)
//  //: for different assets, operations (according to StatsOpType), particular account roles, particular accounts,
//  //: or globally (only if both parameters particular account role and paticular account are not specified),
//  struct LimitsV2Entry
//  {
//      //: ID of limits entry
//      uint64      id;
//      //: (optional) ID of an account role that will be imposed with limits
//      uint64*     accountRole;
//      //: (optional) ID of an account that will be imposed with limits
//      AccountID*  accountID;
//      //: Operation type that will be imposed with limits. See `enum StatsOpType`
//      StatsOpType statsOpType;
//      //: Asset that will be imposed with limits
//      AssetCode   assetCode;
//      //: `isConvertNeeded` indicates whether or not the asset conversion is needed for the limits entry.
//      //: If this field is `true`, limits are applied to all balances of an account (to every asset that account owns).
//      //: Otherwise, limits from particular limits entry are applied only to  balances with `AssetCode` provided by entry.
//      bool        isConvertNeeded;
//  
//      //: daily out limit
//      uint64 dailyOut;
//      //: weekly out limit
//      uint64 weeklyOut;
//      //: monthly out limit
//      uint64 monthlyOut;
//      //: annual out limit
//      uint64 annualOut;
//  
//      //: reserved for future use
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//  };

//  ===========================================================================
public struct LimitsV2Entry: XDRCodable {
  public var id: Uint64
  public var accountRole: Uint64?
  public var accountID: AccountID?
  public var statsOpType: StatsOpType
  public var assetCode: AssetCode
  public var isConvertNeeded: Bool
  public var dailyOut: Uint64
  public var weeklyOut: Uint64
  public var monthlyOut: Uint64
  public var annualOut: Uint64
  public var ext: LimitsV2EntryExt

  public init(
      id: Uint64,
      accountRole: Uint64?,
      accountID: AccountID?,
      statsOpType: StatsOpType,
      assetCode: AssetCode,
      isConvertNeeded: Bool,
      dailyOut: Uint64,
      weeklyOut: Uint64,
      monthlyOut: Uint64,
      annualOut: Uint64,
      ext: LimitsV2EntryExt) {

    self.id = id
    self.accountRole = accountRole
    self.accountID = accountID
    self.statsOpType = statsOpType
    self.assetCode = assetCode
    self.isConvertNeeded = isConvertNeeded
    self.dailyOut = dailyOut
    self.weeklyOut = weeklyOut
    self.monthlyOut = monthlyOut
    self.annualOut = annualOut
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.id.toXDR())
    xdr.append(self.accountRole.toXDR())
    xdr.append(self.accountID.toXDR())
    xdr.append(self.statsOpType.toXDR())
    xdr.append(self.assetCode.toXDR())
    xdr.append(self.isConvertNeeded.toXDR())
    xdr.append(self.dailyOut.toXDR())
    xdr.append(self.weeklyOut.toXDR())
    xdr.append(self.monthlyOut.toXDR())
    xdr.append(self.annualOut.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public init(xdrData: inout Data) throws {
    self.id = try Uint64(xdrData: &xdrData)
    if (try Bool(xdrData: &xdrData)) {
      self.accountRole = try Uint64(xdrData: &xdrData)
    } else {
      self.accountRole = nil
    }
    if (try Bool(xdrData: &xdrData)) {
      self.accountID = try AccountID(xdrData: &xdrData)
    } else {
      self.accountID = nil
    }
    self.statsOpType = try StatsOpType(xdrData: &xdrData)
    self.assetCode = try AssetCode(xdrData: &xdrData)
    self.isConvertNeeded = try Bool(xdrData: &xdrData)
    self.dailyOut = try Uint64(xdrData: &xdrData)
    self.weeklyOut = try Uint64(xdrData: &xdrData)
    self.monthlyOut = try Uint64(xdrData: &xdrData)
    self.annualOut = try Uint64(xdrData: &xdrData)
    self.ext = try LimitsV2EntryExt(xdrData: &xdrData)
  }

  public enum LimitsV2EntryExt: XDRDiscriminatedUnion {
    case emptyVersion

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.discriminant.toXDR())

      switch self {
      case .emptyVersion: xdr.append(Data())
      }

      return xdr
    }

    public init(xdrData: inout Data) throws {
      let discriminant = try Int32(xdrData: &xdrData)

      switch discriminant {
      case LedgerVersion.emptyVersion.rawValue: self = .emptyVersion
      default:
        throw XDRErrors.unknownEnumCase
      }
    }

  }
}
