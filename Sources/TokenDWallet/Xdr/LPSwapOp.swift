// Automatically generated by xdrgen
// DO NOT EDIT or your changes may be overwritten

import Foundation

// === xdr source ============================================================

//  struct LPSwapOp
//      {
//          //: Balance of the provided asset
//          BalanceID fromBalance;
//          //: Balance of the desired asset
//          BalanceID toBalance;
//  
//          union switch(LPSwapType type)
//          {
//              //: Execute swap for exact output amount
//              case EXACT_OUT_TOKENS_FOR_IN_TOKENS:
//                  struct
//                  {
//                      //: Maximum amount to send in the swap
//                      uint64 amountInMax;
//                      //: Desired amount to be received
//                      uint64 amountOut;
//                  } swapExactOutTokensForInTokens;
//              //: Execute swap for exact input amount 
//              case EXACT_IN_TOKENS_FOR_OUT_TOKENS:
//                  struct
//                  {
//                      //: Amount to send in the swap
//                      uint64 amountIn;
//                      //: Minimum amount to be received
//                      uint64 amountOutMin;
//                  } swapExactInTokensForOutTokens;
//          } lpSwapRequest;
//  
//          //: Fee data for the swap
//          PaymentFeeData feeData;
//  
//          //: Reserved for future use
//          EmptyExt ext;
//      };

//  ===========================================================================
public struct LPSwapOp: XDRCodable {
  public var fromBalance: BalanceID
  public var toBalance: BalanceID
  public var lpSwapRequest: LPSwapOpLpSwapRequest
  public var feeData: PaymentFeeData
  public var ext: EmptyExt

  public init(
      fromBalance: BalanceID,
      toBalance: BalanceID,
      lpSwapRequest: LPSwapOpLpSwapRequest,
      feeData: PaymentFeeData,
      ext: EmptyExt) {

    self.fromBalance = fromBalance
    self.toBalance = toBalance
    self.lpSwapRequest = lpSwapRequest
    self.feeData = feeData
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.fromBalance.toXDR())
    xdr.append(self.toBalance.toXDR())
    xdr.append(self.lpSwapRequest.toXDR())
    xdr.append(self.feeData.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public init(xdrData: inout Data) throws {
    self.fromBalance = try BalanceID(xdrData: &xdrData)
    self.toBalance = try BalanceID(xdrData: &xdrData)
    self.lpSwapRequest = try LPSwapOpLpSwapRequest(xdrData: &xdrData)
    self.feeData = try PaymentFeeData(xdrData: &xdrData)
    self.ext = try EmptyExt(xdrData: &xdrData)
  }

  public enum LPSwapOpLpSwapRequest: XDRDiscriminatedUnion {
    case exactOutTokensForInTokens(LPSwapOpSwapExactOutTokensForInTokens)
    case exactInTokensForOutTokens(LPSwapOpSwapExactInTokensForOutTokens)

    public var discriminant: Int32 {
      switch self {
      case .exactOutTokensForInTokens: return LPSwapType.exactOutTokensForInTokens.rawValue
      case .exactInTokensForOutTokens: return LPSwapType.exactInTokensForOutTokens.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.discriminant.toXDR())

      switch self {
      case .exactOutTokensForInTokens(let data): xdr.append(data.toXDR())
      case .exactInTokensForOutTokens(let data): xdr.append(data.toXDR())
      }

      return xdr
    }

    public init(xdrData: inout Data) throws {
      let discriminant = try Int32(xdrData: &xdrData)

      switch discriminant {
      case LPSwapType.exactOutTokensForInTokens.rawValue:
        let data = try LPSwapOpSwapExactOutTokensForInTokens(xdrData: &xdrData)
        self = .exactOutTokensForInTokens(data)
      case LPSwapType.exactInTokensForOutTokens.rawValue:
        let data = try LPSwapOpSwapExactInTokensForOutTokens(xdrData: &xdrData)
        self = .exactInTokensForOutTokens(data)
      default:
        throw XDRErrors.unknownEnumCase
      }
    }

    public struct LPSwapOpSwapExactOutTokensForInTokens: XDRCodable {
      public var amountInMax: Uint64
      public var amountOut: Uint64

      public init(
          amountInMax: Uint64,
          amountOut: Uint64) {

        self.amountInMax = amountInMax
        self.amountOut = amountOut
      }

      public func toXDR() -> Data {
        var xdr = Data()

        xdr.append(self.amountInMax.toXDR())
        xdr.append(self.amountOut.toXDR())

        return xdr
      }

      public init(xdrData: inout Data) throws {
        self.amountInMax = try Uint64(xdrData: &xdrData)
        self.amountOut = try Uint64(xdrData: &xdrData)
      }

    }
    public struct LPSwapOpSwapExactInTokensForOutTokens: XDRCodable {
      public var amountIn: Uint64
      public var amountOutMin: Uint64

      public init(
          amountIn: Uint64,
          amountOutMin: Uint64) {

        self.amountIn = amountIn
        self.amountOutMin = amountOutMin
      }

      public func toXDR() -> Data {
        var xdr = Data()

        xdr.append(self.amountIn.toXDR())
        xdr.append(self.amountOutMin.toXDR())

        return xdr
      }

      public init(xdrData: inout Data) throws {
        self.amountIn = try Uint64(xdrData: &xdrData)
        self.amountOutMin = try Uint64(xdrData: &xdrData)
      }

    }
  }
}
