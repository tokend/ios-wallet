// Automatically generated by xdrgen
// DO NOT EDIT or your changes may be overwritten

import Foundation

// === xdr source ============================================================

//  struct OpenSwapOp
//  {
//      //: Source balance of the swap
//      BalanceID sourceBalance;
//      //: Amount to send in swap
//      uint64 amount;
//  
//     //: `destination` defines the type of instance that receives amount based on given PaymentDestinationType
//     union switch (PaymentDestinationType type) {
//         case ACCOUNT:
//             AccountID accountID;
//         case BALANCE:
//             BalanceID balanceID;
//     } destination;
//  
//      //: Fee data for the swap
//      PaymentFeeData feeData;
//      //: Arbitrary stringified json object provided by swap source
//      longstring details;
//  
//      //: Hash of the secret
//      Hash secretHash;
//      //: Time till which swapped funds can be received by destination if valid secret is provided
//      int64 lockTime;
//  
//      //: reserved for future extension
//      EmptyExt ext;
//  };

//  ===========================================================================
public struct OpenSwapOp: XDRCodable {
  public var sourceBalance: BalanceID
  public var amount: Uint64
  public var destination: OpenSwapOpDestination
  public var feeData: PaymentFeeData
  public var details: Longstring
  public var secretHash: Hash
  public var lockTime: Int64
  public var ext: EmptyExt

  public init(
      sourceBalance: BalanceID,
      amount: Uint64,
      destination: OpenSwapOpDestination,
      feeData: PaymentFeeData,
      details: Longstring,
      secretHash: Hash,
      lockTime: Int64,
      ext: EmptyExt) {

    self.sourceBalance = sourceBalance
    self.amount = amount
    self.destination = destination
    self.feeData = feeData
    self.details = details
    self.secretHash = secretHash
    self.lockTime = lockTime
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.sourceBalance.toXDR())
    xdr.append(self.amount.toXDR())
    xdr.append(self.destination.toXDR())
    xdr.append(self.feeData.toXDR())
    xdr.append(self.details.toXDR())
    xdr.append(self.secretHash.toXDR())
    xdr.append(self.lockTime.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public init(xdrData: inout Data) throws {
    self.sourceBalance = try BalanceID(xdrData: &xdrData)
    self.amount = try Uint64(xdrData: &xdrData)
    self.destination = try OpenSwapOpDestination(xdrData: &xdrData)
    self.feeData = try PaymentFeeData(xdrData: &xdrData)
    self.details = try Longstring(xdrData: &xdrData)
    self.secretHash = try Hash(xdrData: &xdrData)
    self.lockTime = try Int64(xdrData: &xdrData)
    self.ext = try EmptyExt(xdrData: &xdrData)
  }

  public enum OpenSwapOpDestination: XDRDiscriminatedUnion {
    case account(AccountID)
    case balance(BalanceID)

    public var discriminant: Int32 {
      switch self {
      case .account: return PaymentDestinationType.account.rawValue
      case .balance: return PaymentDestinationType.balance.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.discriminant.toXDR())

      switch self {
      case .account(let data): xdr.append(data.toXDR())
      case .balance(let data): xdr.append(data.toXDR())
      }

      return xdr
    }

    public init(xdrData: inout Data) throws {
      let discriminant = try Int32(xdrData: &xdrData)

      switch discriminant {
      case PaymentDestinationType.account.rawValue:
        let data = try AccountID(xdrData: &xdrData)
        self = .account(data)
      case PaymentDestinationType.balance.rawValue:
        let data = try BalanceID(xdrData: &xdrData)
        self = .balance(data)
      default:
        throw XDRErrors.unknownEnumCase
      }
    }

  }
}
