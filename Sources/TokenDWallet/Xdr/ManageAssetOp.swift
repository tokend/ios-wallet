// Automatically generated by xdrgen
// DO NOT EDIT or your changes may be overwritten

import Foundation

// === xdr source ============================================================

//  //: ManageAssetOp is used to:
//  //: * create or update `CREATE_ASSET` request;
//  //: * create or update `UPDATE_ASSET` request;
//  //: * cancel `CREATE_ASSET` or `UPDATE_ASSET` request
//  //: * change asset pre issuer
//  //: * update max issuance of an asset
//  struct ManageAssetOp
//  {
//      //: ID of a reviewable request
//      //: If `requestID == 0`, operation creates a new reviewable request; otherwise, it updates the existing one 
//      uint64 requestID;
//  
//      //: data is used to pass one of `ManageAssetAction` with required params
//      union switch (ManageAssetAction action)
//      {
//      case CREATE_ASSET_CREATION_REQUEST:
//          //: Is used to pass required fields for `CREATE_ASSET`
//          struct
//          {
//              //: Is used to pass required fields to create an asset entry
//              AssetCreationRequest createAsset;
//              //: (optional) Bit mask whose flags must be cleared in order for `CREATE_ASSET` request to be approved, which will be used by key `asset_create_tasks`
//              //: instead of key-value
//              uint32* allTasks;
//  
//              //: reserved for future use
//              union switch (LedgerVersion v)
//              {
//              case EMPTY_VERSION:
//                  void;
//              }
//              ext;
//          } createAssetCreationRequest;
//      case CREATE_ASSET_UPDATE_REQUEST:
//          //: Is used to pass needed fields for `UPDATE_ASSET`
//          struct
//          {
//              //: Is used to pass required fields to update an asset entry
//              AssetUpdateRequest updateAsset;
//              //: (optional) Bit mask whose flags must be cleared in order for `UPDATE_ASSET` request to be approved, which will be used
//              //: instead of key-value by key `asset_update_tasks`
//              uint32* allTasks;
//  
//              //: reserved for future use
//              union switch (LedgerVersion v)
//              {
//              case EMPTY_VERSION:
//                  void;
//              }
//              ext;
//          } createAssetUpdateRequest;
//      case CANCEL_ASSET_REQUEST:
//          //: Reserved for future use
//          CancelAssetRequest cancelRequest;
//      case CHANGE_PREISSUED_ASSET_SIGNER:
//          //: Is used to pass required fields to change an asset pre issuer
//          AssetChangePreissuedSigner changePreissuedSigner;
//      case UPDATE_MAX_ISSUANCE:
//          //: Is used to update max issuance of asset
//          UpdateMaxIssuance updateMaxIssuance;
//      } request;
//  
//      //: reserved for future use
//      union switch (LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      }
//      ext;
//  };

//  ===========================================================================
public struct ManageAssetOp: XDRCodable {
  public var requestID: Uint64
  public var request: ManageAssetOpRequest
  public var ext: ManageAssetOpExt

  public init(
      requestID: Uint64,
      request: ManageAssetOpRequest,
      ext: ManageAssetOpExt) {

    self.requestID = requestID
    self.request = request
    self.ext = ext
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.requestID.toXDR())
    xdr.append(self.request.toXDR())
    xdr.append(self.ext.toXDR())

    return xdr
  }

  public init(xdrData: inout Data) throws {
    self.requestID = try Uint64(xdrData: &xdrData)
    self.request = try ManageAssetOpRequest(xdrData: &xdrData)
    self.ext = try ManageAssetOpExt(xdrData: &xdrData)
  }

  public enum ManageAssetOpRequest: XDRDiscriminatedUnion {
    case createAssetCreationRequest(ManageAssetOpCreateAssetCreationRequest)
    case createAssetUpdateRequest(ManageAssetOpCreateAssetUpdateRequest)
    case cancelAssetRequest(CancelAssetRequest)
    case changePreissuedAssetSigner(AssetChangePreissuedSigner)
    case updateMaxIssuance(UpdateMaxIssuance)

    public var discriminant: Int32 {
      switch self {
      case .createAssetCreationRequest: return ManageAssetAction.createAssetCreationRequest.rawValue
      case .createAssetUpdateRequest: return ManageAssetAction.createAssetUpdateRequest.rawValue
      case .cancelAssetRequest: return ManageAssetAction.cancelAssetRequest.rawValue
      case .changePreissuedAssetSigner: return ManageAssetAction.changePreissuedAssetSigner.rawValue
      case .updateMaxIssuance: return ManageAssetAction.updateMaxIssuance.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.discriminant.toXDR())

      switch self {
      case .createAssetCreationRequest(let data): xdr.append(data.toXDR())
      case .createAssetUpdateRequest(let data): xdr.append(data.toXDR())
      case .cancelAssetRequest(let data): xdr.append(data.toXDR())
      case .changePreissuedAssetSigner(let data): xdr.append(data.toXDR())
      case .updateMaxIssuance(let data): xdr.append(data.toXDR())
      }

      return xdr
    }

    public init(xdrData: inout Data) throws {
      let discriminant = try Int32(xdrData: &xdrData)

      switch discriminant {
      case ManageAssetAction.createAssetCreationRequest.rawValue:
        let data = try ManageAssetOpCreateAssetCreationRequest(xdrData: &xdrData)
        self = .createAssetCreationRequest(data)
      case ManageAssetAction.createAssetUpdateRequest.rawValue:
        let data = try ManageAssetOpCreateAssetUpdateRequest(xdrData: &xdrData)
        self = .createAssetUpdateRequest(data)
      case ManageAssetAction.cancelAssetRequest.rawValue:
        let data = try CancelAssetRequest(xdrData: &xdrData)
        self = .cancelAssetRequest(data)
      case ManageAssetAction.changePreissuedAssetSigner.rawValue:
        let data = try AssetChangePreissuedSigner(xdrData: &xdrData)
        self = .changePreissuedAssetSigner(data)
      case ManageAssetAction.updateMaxIssuance.rawValue:
        let data = try UpdateMaxIssuance(xdrData: &xdrData)
        self = .updateMaxIssuance(data)
      default:
        throw XDRErrors.unknownEnumCase
      }
    }

    public struct ManageAssetOpCreateAssetCreationRequest: XDRCodable {
      public var createAsset: AssetCreationRequest
      public var allTasks: Uint32?
      public var ext: ManageAssetOpCreateAssetCreationRequestExt

      public init(
          createAsset: AssetCreationRequest,
          allTasks: Uint32?,
          ext: ManageAssetOpCreateAssetCreationRequestExt) {

        self.createAsset = createAsset
        self.allTasks = allTasks
        self.ext = ext
      }

      public func toXDR() -> Data {
        var xdr = Data()

        xdr.append(self.createAsset.toXDR())
        xdr.append(self.allTasks.toXDR())
        xdr.append(self.ext.toXDR())

        return xdr
      }

      public init(xdrData: inout Data) throws {
        self.createAsset = try AssetCreationRequest(xdrData: &xdrData)
        if (try Bool(xdrData: &xdrData)) {
          self.allTasks = try Uint32(xdrData: &xdrData)
        } else {
          self.allTasks = nil
        }
        self.ext = try ManageAssetOpCreateAssetCreationRequestExt(xdrData: &xdrData)
      }

      public enum ManageAssetOpCreateAssetCreationRequestExt: XDRDiscriminatedUnion {
        case emptyVersion

        public var discriminant: Int32 {
          switch self {
          case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
          }
        }

        public func toXDR() -> Data {
          var xdr = Data()

          xdr.append(self.discriminant.toXDR())

          switch self {
          case .emptyVersion: xdr.append(Data())
          }

          return xdr
        }

        public init(xdrData: inout Data) throws {
          let discriminant = try Int32(xdrData: &xdrData)

          switch discriminant {
          case LedgerVersion.emptyVersion.rawValue: self = .emptyVersion
          default:
            throw XDRErrors.unknownEnumCase
          }
        }

      }
    }
    public struct ManageAssetOpCreateAssetUpdateRequest: XDRCodable {
      public var updateAsset: AssetUpdateRequest
      public var allTasks: Uint32?
      public var ext: ManageAssetOpCreateAssetUpdateRequestExt

      public init(
          updateAsset: AssetUpdateRequest,
          allTasks: Uint32?,
          ext: ManageAssetOpCreateAssetUpdateRequestExt) {

        self.updateAsset = updateAsset
        self.allTasks = allTasks
        self.ext = ext
      }

      public func toXDR() -> Data {
        var xdr = Data()

        xdr.append(self.updateAsset.toXDR())
        xdr.append(self.allTasks.toXDR())
        xdr.append(self.ext.toXDR())

        return xdr
      }

      public init(xdrData: inout Data) throws {
        self.updateAsset = try AssetUpdateRequest(xdrData: &xdrData)
        if (try Bool(xdrData: &xdrData)) {
          self.allTasks = try Uint32(xdrData: &xdrData)
        } else {
          self.allTasks = nil
        }
        self.ext = try ManageAssetOpCreateAssetUpdateRequestExt(xdrData: &xdrData)
      }

      public enum ManageAssetOpCreateAssetUpdateRequestExt: XDRDiscriminatedUnion {
        case emptyVersion

        public var discriminant: Int32 {
          switch self {
          case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
          }
        }

        public func toXDR() -> Data {
          var xdr = Data()

          xdr.append(self.discriminant.toXDR())

          switch self {
          case .emptyVersion: xdr.append(Data())
          }

          return xdr
        }

        public init(xdrData: inout Data) throws {
          let discriminant = try Int32(xdrData: &xdrData)

          switch discriminant {
          case LedgerVersion.emptyVersion.rawValue: self = .emptyVersion
          default:
            throw XDRErrors.unknownEnumCase
          }
        }

      }
    }
  }
  public enum ManageAssetOpExt: XDRDiscriminatedUnion {
    case emptyVersion

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.discriminant.toXDR())

      switch self {
      case .emptyVersion: xdr.append(Data())
      }

      return xdr
    }

    public init(xdrData: inout Data) throws {
      let discriminant = try Int32(xdrData: &xdrData)

      switch discriminant {
      case LedgerVersion.emptyVersion.rawValue: self = .emptyVersion
      default:
        throw XDRErrors.unknownEnumCase
      }
    }

  }
}
