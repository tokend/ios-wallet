// Automatically generated by xdrgen
// DO NOT EDIT or your changes may be overwritten

import Foundation

// === xdr source ============================================================

//  union LedgerKey switch (LedgerEntryType type)
//  {
//  case ACCOUNT:
//      struct
//      {
//          AccountID accountID;
//          union switch (LedgerVersion v)
//         {
//         case EMPTY_VERSION:
//            void;
//         }
//         ext;
//      } account;
//  case SIGNER:
//      struct
//      {
//          PublicKey pubKey;
//          AccountID accountID;
//  
//          union switch (LedgerVersion v)
//          {
//          case EMPTY_VERSION:
//              void;
//          }
//          ext;
//      } signer;
//  case FEE:
//      struct {
//          Hash hash;
//          int64 lowerBound;
//          int64 upperBound;
//          union switch (LedgerVersion v)
//          {
//          case EMPTY_VERSION:
//              void;
//          }
//          ext;
//      } feeState;
//  case BALANCE:
//      struct
//      {
//          BalanceID balanceID;
//          union switch (LedgerVersion v)
//          {
//          case EMPTY_VERSION:
//              void;
//          }
//          ext;
//      } balance;
//  case ASSET:
//      struct
//      {
//          AssetCode code;
//          union switch (LedgerVersion v)
//          {
//          case EMPTY_VERSION:
//              void;
//          }
//          ext;
//      } asset;
//  case REFERENCE_ENTRY:
//      struct
//      {
//  		AccountID sender;
//  		string64 reference;
//  		union switch (LedgerVersion v)
//  		{
//  		case EMPTY_VERSION:
//  			void;
//  		}
//  		ext;
//      } reference;
//  case STATISTICS:
//      struct {
//          AccountID accountID;
//  		union switch (LedgerVersion v)
//  		{
//  		case EMPTY_VERSION:
//  			void;
//  		}
//  		ext;
//      } stats;
//  case ACCOUNT_LIMITS:
//      struct {
//          AccountID accountID;
//  		union switch (LedgerVersion v)
//  		{
//  		case EMPTY_VERSION:
//  			void;
//  		}
//  		ext;
//      } accountLimits;
//  case ASSET_PAIR:
//      struct {
//          AssetCode base;
//          AssetCode quote;
//          union switch (LedgerVersion v)
//          {
//          case EMPTY_VERSION:
//              void;
//          }
//          ext;
//      } assetPair;
//  case OFFER_ENTRY:
//      struct {
//          uint64 offerID;
//          AccountID ownerID;
//      } offer;
//  case REVIEWABLE_REQUEST:
//      struct {
//          uint64 requestID;
//          union switch (LedgerVersion v)
//          {
//          case EMPTY_VERSION:
//              void;
//          }
//          ext;
//      } reviewableRequest;
//  case EXTERNAL_SYSTEM_ACCOUNT_ID:
//  	struct {
//  		AccountID accountID;
//  		int32 externalSystemType;
//  		union switch (LedgerVersion v)
//  		{
//  		case EMPTY_VERSION:
//  			void;
//  		}
//  		ext;
//  	} externalSystemAccountID;
//  case SALE:
//      struct {
//          uint64 saleID;
//          union switch (LedgerVersion v)
//          {
//          case EMPTY_VERSION:
//              void;
//          }
//          ext;
//      } sale;
//  case KEY_VALUE:
//      struct {
//          longstring key;
//          union switch (LedgerVersion v)
//          {
//          case EMPTY_VERSION:
//              void;
//          }
//          ext;
//      } keyValue;
//  case ACCOUNT_KYC:
//      struct {
//          AccountID accountID;
//          union switch(LedgerVersion v)
//          {
//          case EMPTY_VERSION:
//              void;
//          }
//          ext;
//      } accountKYC;
//  case EXTERNAL_SYSTEM_ACCOUNT_ID_POOL_ENTRY:
//      struct {
//  		uint64 poolEntryID;
//  		union switch (LedgerVersion v)
//  		{
//  		case EMPTY_VERSION:
//  			void;
//  		}
//  		ext;
//  	} externalSystemAccountIDPoolEntry;
//  case LIMITS_V2:
//      struct {
//          uint64 id;
//          union switch (LedgerVersion v)
//          {
//          case EMPTY_VERSION:
//              void;
//          } ext;
//      } limitsV2;
//  case STATISTICS_V2:
//      struct {
//          uint64 id;
//          union switch (LedgerVersion v)
//          {
//          case EMPTY_VERSION:
//              void;
//          }
//          ext;
//      } statisticsV2;
//  case PENDING_STATISTICS:
//      struct {
//          uint64 statisticsID;
//          uint64 requestID;
//          union switch (LedgerVersion v)
//          {
//          case EMPTY_VERSION:
//              void;
//          }
//          ext;
//      } pendingStatistics;
//  case CONTRACT:
//      struct {
//          uint64 contractID;
//          union switch (LedgerVersion v)
//          {
//          case EMPTY_VERSION:
//              void;
//          }
//          ext;
//      } contract;
//  case ATOMIC_SWAP_ASK:
//      struct {
//          uint64 id;
//          union switch (LedgerVersion v)
//          {
//          case EMPTY_VERSION:
//              void;
//          }
//          ext;
//      } atomicSwapAsk;
//  case ACCOUNT_ROLE:
//      struct {
//          uint64 id;
//          union switch (LedgerVersion v)
//          {
//          case EMPTY_VERSION:
//              void;
//          }
//          ext;
//      } accountRole;
//  case ACCOUNT_RULE:
//      struct {
//          uint64 id;
//          union switch (LedgerVersion v)
//          {
//          case EMPTY_VERSION:
//              void;
//          }
//          ext;
//      } accountRule;
//  case SIGNER_ROLE:
//      struct {
//          uint64 id;
//          union switch (LedgerVersion v)
//          {
//          case EMPTY_VERSION:
//              void;
//          }
//          ext;
//      } signerRole;
//  case SIGNER_RULE:
//      struct {
//          uint64 id;
//          union switch (LedgerVersion v)
//          {
//          case EMPTY_VERSION:
//              void;
//          }
//          ext;
//      } signerRule;
//  case STAMP:
//      struct {
//          Hash ledgerHash;
//          Hash licenseHash;
//          union switch (LedgerVersion v)
//          {
//          case EMPTY_VERSION:
//              void;
//          }
//          ext;
//      } stamp;
//  case LICENSE:
//      struct {
//          Hash licenseHash;
//          union switch (LedgerVersion v)
//          {
//          case EMPTY_VERSION:
//              void;
//          } ext;
//      } license;
//  case POLL:
//      struct {
//          uint64 id;
//  
//          EmptyExt ext;
//      } poll;
//  case VOTE:
//      struct {
//          uint64 pollID;
//          AccountID voterID;
//  
//          EmptyExt ext;
//      } vote;
//  case ACCOUNT_SPECIFIC_RULE:
//      struct {
//          uint64 id;
//  
//          EmptyExt ext;
//      } accountSpecificRule;
//  case SWAP:
//      struct
//      {
//          uint64 id;
//  
//          EmptyExt ext;
//      } swap;
//  case DATA:
//      struct {
//          uint64 id;
//  
//          EmptyExt ext;
//      } data;
//  case DEFERRED_PAYMENT:
//      struct {
//          uint64 id;
//  
//          EmptyExt ext;
//      } deferredPayment;
//  case LIQUIDITY_POOL:
//      struct {
//          uint64 id;
//  
//          EmptyExt ext;
//      } liquidityPool;
//  };

//  ===========================================================================
public enum LedgerKey: XDRDiscriminatedUnion {
  case account(LedgerKeyAccount)
  case signer(LedgerKeySigner)
  case fee(LedgerKeyFeeState)
  case balance(LedgerKeyBalance)
  case asset(LedgerKeyAsset)
  case referenceEntry(LedgerKeyReference)
  case statistics(LedgerKeyStats)
  case accountLimits(LedgerKeyAccountLimits)
  case assetPair(LedgerKeyAssetPair)
  case offerEntry(LedgerKeyOffer)
  case reviewableRequest(LedgerKeyReviewableRequest)
  case externalSystemAccountId(LedgerKeyExternalSystemAccountID)
  case sale(LedgerKeySale)
  case keyValue(LedgerKeyKeyValue)
  case accountKyc(LedgerKeyAccountKYC)
  case externalSystemAccountIdPoolEntry(LedgerKeyExternalSystemAccountIDPoolEntry)
  case limitsV2(LedgerKeyLimitsV2)
  case statisticsV2(LedgerKeyStatisticsV2)
  case pendingStatistics(LedgerKeyPendingStatistics)
  case contract(LedgerKeyContract)
  case atomicSwapAsk(LedgerKeyAtomicSwapAsk)
  case accountRole(LedgerKeyAccountRole)
  case accountRule(LedgerKeyAccountRule)
  case signerRole(LedgerKeySignerRole)
  case signerRule(LedgerKeySignerRule)
  case stamp(LedgerKeyStamp)
  case license(LedgerKeyLicense)
  case poll(LedgerKeyPoll)
  case vote(LedgerKeyVote)
  case accountSpecificRule(LedgerKeyAccountSpecificRule)
  case swap(LedgerKeySwap)
  case data(LedgerKeyData)
  case deferredPayment(LedgerKeyDeferredPayment)
  case liquidityPool(LedgerKeyLiquidityPool)

  public var discriminant: Int32 {
    switch self {
    case .account: return LedgerEntryType.account.rawValue
    case .signer: return LedgerEntryType.signer.rawValue
    case .fee: return LedgerEntryType.fee.rawValue
    case .balance: return LedgerEntryType.balance.rawValue
    case .asset: return LedgerEntryType.asset.rawValue
    case .referenceEntry: return LedgerEntryType.referenceEntry.rawValue
    case .statistics: return LedgerEntryType.statistics.rawValue
    case .accountLimits: return LedgerEntryType.accountLimits.rawValue
    case .assetPair: return LedgerEntryType.assetPair.rawValue
    case .offerEntry: return LedgerEntryType.offerEntry.rawValue
    case .reviewableRequest: return LedgerEntryType.reviewableRequest.rawValue
    case .externalSystemAccountId: return LedgerEntryType.externalSystemAccountId.rawValue
    case .sale: return LedgerEntryType.sale.rawValue
    case .keyValue: return LedgerEntryType.keyValue.rawValue
    case .accountKyc: return LedgerEntryType.accountKyc.rawValue
    case .externalSystemAccountIdPoolEntry: return LedgerEntryType.externalSystemAccountIdPoolEntry.rawValue
    case .limitsV2: return LedgerEntryType.limitsV2.rawValue
    case .statisticsV2: return LedgerEntryType.statisticsV2.rawValue
    case .pendingStatistics: return LedgerEntryType.pendingStatistics.rawValue
    case .contract: return LedgerEntryType.contract.rawValue
    case .atomicSwapAsk: return LedgerEntryType.atomicSwapAsk.rawValue
    case .accountRole: return LedgerEntryType.accountRole.rawValue
    case .accountRule: return LedgerEntryType.accountRule.rawValue
    case .signerRole: return LedgerEntryType.signerRole.rawValue
    case .signerRule: return LedgerEntryType.signerRule.rawValue
    case .stamp: return LedgerEntryType.stamp.rawValue
    case .license: return LedgerEntryType.license.rawValue
    case .poll: return LedgerEntryType.poll.rawValue
    case .vote: return LedgerEntryType.vote.rawValue
    case .accountSpecificRule: return LedgerEntryType.accountSpecificRule.rawValue
    case .swap: return LedgerEntryType.swap.rawValue
    case .data: return LedgerEntryType.data.rawValue
    case .deferredPayment: return LedgerEntryType.deferredPayment.rawValue
    case .liquidityPool: return LedgerEntryType.liquidityPool.rawValue
    }
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.discriminant.toXDR())

    switch self {
    case .account(let data): xdr.append(data.toXDR())
    case .signer(let data): xdr.append(data.toXDR())
    case .fee(let data): xdr.append(data.toXDR())
    case .balance(let data): xdr.append(data.toXDR())
    case .asset(let data): xdr.append(data.toXDR())
    case .referenceEntry(let data): xdr.append(data.toXDR())
    case .statistics(let data): xdr.append(data.toXDR())
    case .accountLimits(let data): xdr.append(data.toXDR())
    case .assetPair(let data): xdr.append(data.toXDR())
    case .offerEntry(let data): xdr.append(data.toXDR())
    case .reviewableRequest(let data): xdr.append(data.toXDR())
    case .externalSystemAccountId(let data): xdr.append(data.toXDR())
    case .sale(let data): xdr.append(data.toXDR())
    case .keyValue(let data): xdr.append(data.toXDR())
    case .accountKyc(let data): xdr.append(data.toXDR())
    case .externalSystemAccountIdPoolEntry(let data): xdr.append(data.toXDR())
    case .limitsV2(let data): xdr.append(data.toXDR())
    case .statisticsV2(let data): xdr.append(data.toXDR())
    case .pendingStatistics(let data): xdr.append(data.toXDR())
    case .contract(let data): xdr.append(data.toXDR())
    case .atomicSwapAsk(let data): xdr.append(data.toXDR())
    case .accountRole(let data): xdr.append(data.toXDR())
    case .accountRule(let data): xdr.append(data.toXDR())
    case .signerRole(let data): xdr.append(data.toXDR())
    case .signerRule(let data): xdr.append(data.toXDR())
    case .stamp(let data): xdr.append(data.toXDR())
    case .license(let data): xdr.append(data.toXDR())
    case .poll(let data): xdr.append(data.toXDR())
    case .vote(let data): xdr.append(data.toXDR())
    case .accountSpecificRule(let data): xdr.append(data.toXDR())
    case .swap(let data): xdr.append(data.toXDR())
    case .data(let data): xdr.append(data.toXDR())
    case .deferredPayment(let data): xdr.append(data.toXDR())
    case .liquidityPool(let data): xdr.append(data.toXDR())
    }

    return xdr
  }

  public init(xdrData: inout Data) throws {
    let discriminant = try Int32(xdrData: &xdrData)

    switch discriminant {
    case LedgerEntryType.account.rawValue:
      let data = try LedgerKeyAccount(xdrData: &xdrData)
      self = .account(data)
    case LedgerEntryType.signer.rawValue:
      let data = try LedgerKeySigner(xdrData: &xdrData)
      self = .signer(data)
    case LedgerEntryType.fee.rawValue:
      let data = try LedgerKeyFeeState(xdrData: &xdrData)
      self = .fee(data)
    case LedgerEntryType.balance.rawValue:
      let data = try LedgerKeyBalance(xdrData: &xdrData)
      self = .balance(data)
    case LedgerEntryType.asset.rawValue:
      let data = try LedgerKeyAsset(xdrData: &xdrData)
      self = .asset(data)
    case LedgerEntryType.referenceEntry.rawValue:
      let data = try LedgerKeyReference(xdrData: &xdrData)
      self = .referenceEntry(data)
    case LedgerEntryType.statistics.rawValue:
      let data = try LedgerKeyStats(xdrData: &xdrData)
      self = .statistics(data)
    case LedgerEntryType.accountLimits.rawValue:
      let data = try LedgerKeyAccountLimits(xdrData: &xdrData)
      self = .accountLimits(data)
    case LedgerEntryType.assetPair.rawValue:
      let data = try LedgerKeyAssetPair(xdrData: &xdrData)
      self = .assetPair(data)
    case LedgerEntryType.offerEntry.rawValue:
      let data = try LedgerKeyOffer(xdrData: &xdrData)
      self = .offerEntry(data)
    case LedgerEntryType.reviewableRequest.rawValue:
      let data = try LedgerKeyReviewableRequest(xdrData: &xdrData)
      self = .reviewableRequest(data)
    case LedgerEntryType.externalSystemAccountId.rawValue:
      let data = try LedgerKeyExternalSystemAccountID(xdrData: &xdrData)
      self = .externalSystemAccountId(data)
    case LedgerEntryType.sale.rawValue:
      let data = try LedgerKeySale(xdrData: &xdrData)
      self = .sale(data)
    case LedgerEntryType.keyValue.rawValue:
      let data = try LedgerKeyKeyValue(xdrData: &xdrData)
      self = .keyValue(data)
    case LedgerEntryType.accountKyc.rawValue:
      let data = try LedgerKeyAccountKYC(xdrData: &xdrData)
      self = .accountKyc(data)
    case LedgerEntryType.externalSystemAccountIdPoolEntry.rawValue:
      let data = try LedgerKeyExternalSystemAccountIDPoolEntry(xdrData: &xdrData)
      self = .externalSystemAccountIdPoolEntry(data)
    case LedgerEntryType.limitsV2.rawValue:
      let data = try LedgerKeyLimitsV2(xdrData: &xdrData)
      self = .limitsV2(data)
    case LedgerEntryType.statisticsV2.rawValue:
      let data = try LedgerKeyStatisticsV2(xdrData: &xdrData)
      self = .statisticsV2(data)
    case LedgerEntryType.pendingStatistics.rawValue:
      let data = try LedgerKeyPendingStatistics(xdrData: &xdrData)
      self = .pendingStatistics(data)
    case LedgerEntryType.contract.rawValue:
      let data = try LedgerKeyContract(xdrData: &xdrData)
      self = .contract(data)
    case LedgerEntryType.atomicSwapAsk.rawValue:
      let data = try LedgerKeyAtomicSwapAsk(xdrData: &xdrData)
      self = .atomicSwapAsk(data)
    case LedgerEntryType.accountRole.rawValue:
      let data = try LedgerKeyAccountRole(xdrData: &xdrData)
      self = .accountRole(data)
    case LedgerEntryType.accountRule.rawValue:
      let data = try LedgerKeyAccountRule(xdrData: &xdrData)
      self = .accountRule(data)
    case LedgerEntryType.signerRole.rawValue:
      let data = try LedgerKeySignerRole(xdrData: &xdrData)
      self = .signerRole(data)
    case LedgerEntryType.signerRule.rawValue:
      let data = try LedgerKeySignerRule(xdrData: &xdrData)
      self = .signerRule(data)
    case LedgerEntryType.stamp.rawValue:
      let data = try LedgerKeyStamp(xdrData: &xdrData)
      self = .stamp(data)
    case LedgerEntryType.license.rawValue:
      let data = try LedgerKeyLicense(xdrData: &xdrData)
      self = .license(data)
    case LedgerEntryType.poll.rawValue:
      let data = try LedgerKeyPoll(xdrData: &xdrData)
      self = .poll(data)
    case LedgerEntryType.vote.rawValue:
      let data = try LedgerKeyVote(xdrData: &xdrData)
      self = .vote(data)
    case LedgerEntryType.accountSpecificRule.rawValue:
      let data = try LedgerKeyAccountSpecificRule(xdrData: &xdrData)
      self = .accountSpecificRule(data)
    case LedgerEntryType.swap.rawValue:
      let data = try LedgerKeySwap(xdrData: &xdrData)
      self = .swap(data)
    case LedgerEntryType.data.rawValue:
      let data = try LedgerKeyData(xdrData: &xdrData)
      self = .data(data)
    case LedgerEntryType.deferredPayment.rawValue:
      let data = try LedgerKeyDeferredPayment(xdrData: &xdrData)
      self = .deferredPayment(data)
    case LedgerEntryType.liquidityPool.rawValue:
      let data = try LedgerKeyLiquidityPool(xdrData: &xdrData)
      self = .liquidityPool(data)
    default:
      throw XDRErrors.unknownEnumCase
    }
  }
  public struct LedgerKeyAccount: XDRCodable {
    public var accountID: AccountID
    public var ext: LedgerKeyAccountExt

    public init(
        accountID: AccountID,
        ext: LedgerKeyAccountExt) {

      self.accountID = accountID
      self.ext = ext
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.accountID.toXDR())
      xdr.append(self.ext.toXDR())

      return xdr
    }

    public init(xdrData: inout Data) throws {
      self.accountID = try AccountID(xdrData: &xdrData)
      self.ext = try LedgerKeyAccountExt(xdrData: &xdrData)
    }

    public enum LedgerKeyAccountExt: XDRDiscriminatedUnion {
      case emptyVersion

      public var discriminant: Int32 {
        switch self {
        case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
        }
      }

      public func toXDR() -> Data {
        var xdr = Data()

        xdr.append(self.discriminant.toXDR())

        switch self {
        case .emptyVersion: xdr.append(Data())
        }

        return xdr
      }

      public init(xdrData: inout Data) throws {
        let discriminant = try Int32(xdrData: &xdrData)

        switch discriminant {
        case LedgerVersion.emptyVersion.rawValue: self = .emptyVersion
        default:
          throw XDRErrors.unknownEnumCase
        }
      }

    }
  }
  public struct LedgerKeySigner: XDRCodable {
    public var pubKey: PublicKey
    public var accountID: AccountID
    public var ext: LedgerKeySignerExt

    public init(
        pubKey: PublicKey,
        accountID: AccountID,
        ext: LedgerKeySignerExt) {

      self.pubKey = pubKey
      self.accountID = accountID
      self.ext = ext
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.pubKey.toXDR())
      xdr.append(self.accountID.toXDR())
      xdr.append(self.ext.toXDR())

      return xdr
    }

    public init(xdrData: inout Data) throws {
      self.pubKey = try PublicKey(xdrData: &xdrData)
      self.accountID = try AccountID(xdrData: &xdrData)
      self.ext = try LedgerKeySignerExt(xdrData: &xdrData)
    }

    public enum LedgerKeySignerExt: XDRDiscriminatedUnion {
      case emptyVersion

      public var discriminant: Int32 {
        switch self {
        case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
        }
      }

      public func toXDR() -> Data {
        var xdr = Data()

        xdr.append(self.discriminant.toXDR())

        switch self {
        case .emptyVersion: xdr.append(Data())
        }

        return xdr
      }

      public init(xdrData: inout Data) throws {
        let discriminant = try Int32(xdrData: &xdrData)

        switch discriminant {
        case LedgerVersion.emptyVersion.rawValue: self = .emptyVersion
        default:
          throw XDRErrors.unknownEnumCase
        }
      }

    }
  }
  public struct LedgerKeyFeeState: XDRCodable {
    public var hash: Hash
    public var lowerBound: Int64
    public var upperBound: Int64
    public var ext: LedgerKeyFeeStateExt

    public init(
        hash: Hash,
        lowerBound: Int64,
        upperBound: Int64,
        ext: LedgerKeyFeeStateExt) {

      self.hash = hash
      self.lowerBound = lowerBound
      self.upperBound = upperBound
      self.ext = ext
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.hash.toXDR())
      xdr.append(self.lowerBound.toXDR())
      xdr.append(self.upperBound.toXDR())
      xdr.append(self.ext.toXDR())

      return xdr
    }

    public init(xdrData: inout Data) throws {
      self.hash = try Hash(xdrData: &xdrData)
      self.lowerBound = try Int64(xdrData: &xdrData)
      self.upperBound = try Int64(xdrData: &xdrData)
      self.ext = try LedgerKeyFeeStateExt(xdrData: &xdrData)
    }

    public enum LedgerKeyFeeStateExt: XDRDiscriminatedUnion {
      case emptyVersion

      public var discriminant: Int32 {
        switch self {
        case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
        }
      }

      public func toXDR() -> Data {
        var xdr = Data()

        xdr.append(self.discriminant.toXDR())

        switch self {
        case .emptyVersion: xdr.append(Data())
        }

        return xdr
      }

      public init(xdrData: inout Data) throws {
        let discriminant = try Int32(xdrData: &xdrData)

        switch discriminant {
        case LedgerVersion.emptyVersion.rawValue: self = .emptyVersion
        default:
          throw XDRErrors.unknownEnumCase
        }
      }

    }
  }
  public struct LedgerKeyBalance: XDRCodable {
    public var balanceID: BalanceID
    public var ext: LedgerKeyBalanceExt

    public init(
        balanceID: BalanceID,
        ext: LedgerKeyBalanceExt) {

      self.balanceID = balanceID
      self.ext = ext
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.balanceID.toXDR())
      xdr.append(self.ext.toXDR())

      return xdr
    }

    public init(xdrData: inout Data) throws {
      self.balanceID = try BalanceID(xdrData: &xdrData)
      self.ext = try LedgerKeyBalanceExt(xdrData: &xdrData)
    }

    public enum LedgerKeyBalanceExt: XDRDiscriminatedUnion {
      case emptyVersion

      public var discriminant: Int32 {
        switch self {
        case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
        }
      }

      public func toXDR() -> Data {
        var xdr = Data()

        xdr.append(self.discriminant.toXDR())

        switch self {
        case .emptyVersion: xdr.append(Data())
        }

        return xdr
      }

      public init(xdrData: inout Data) throws {
        let discriminant = try Int32(xdrData: &xdrData)

        switch discriminant {
        case LedgerVersion.emptyVersion.rawValue: self = .emptyVersion
        default:
          throw XDRErrors.unknownEnumCase
        }
      }

    }
  }
  public struct LedgerKeyAsset: XDRCodable {
    public var code: AssetCode
    public var ext: LedgerKeyAssetExt

    public init(
        code: AssetCode,
        ext: LedgerKeyAssetExt) {

      self.code = code
      self.ext = ext
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.code.toXDR())
      xdr.append(self.ext.toXDR())

      return xdr
    }

    public init(xdrData: inout Data) throws {
      self.code = try AssetCode(xdrData: &xdrData)
      self.ext = try LedgerKeyAssetExt(xdrData: &xdrData)
    }

    public enum LedgerKeyAssetExt: XDRDiscriminatedUnion {
      case emptyVersion

      public var discriminant: Int32 {
        switch self {
        case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
        }
      }

      public func toXDR() -> Data {
        var xdr = Data()

        xdr.append(self.discriminant.toXDR())

        switch self {
        case .emptyVersion: xdr.append(Data())
        }

        return xdr
      }

      public init(xdrData: inout Data) throws {
        let discriminant = try Int32(xdrData: &xdrData)

        switch discriminant {
        case LedgerVersion.emptyVersion.rawValue: self = .emptyVersion
        default:
          throw XDRErrors.unknownEnumCase
        }
      }

    }
  }
  public struct LedgerKeyReference: XDRCodable {
    public var sender: AccountID
    public var reference: String64
    public var ext: LedgerKeyReferenceExt

    public init(
        sender: AccountID,
        reference: String64,
        ext: LedgerKeyReferenceExt) {

      self.sender = sender
      self.reference = reference
      self.ext = ext
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.sender.toXDR())
      xdr.append(self.reference.toXDR())
      xdr.append(self.ext.toXDR())

      return xdr
    }

    public init(xdrData: inout Data) throws {
      self.sender = try AccountID(xdrData: &xdrData)
      self.reference = try String64(xdrData: &xdrData)
      self.ext = try LedgerKeyReferenceExt(xdrData: &xdrData)
    }

    public enum LedgerKeyReferenceExt: XDRDiscriminatedUnion {
      case emptyVersion

      public var discriminant: Int32 {
        switch self {
        case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
        }
      }

      public func toXDR() -> Data {
        var xdr = Data()

        xdr.append(self.discriminant.toXDR())

        switch self {
        case .emptyVersion: xdr.append(Data())
        }

        return xdr
      }

      public init(xdrData: inout Data) throws {
        let discriminant = try Int32(xdrData: &xdrData)

        switch discriminant {
        case LedgerVersion.emptyVersion.rawValue: self = .emptyVersion
        default:
          throw XDRErrors.unknownEnumCase
        }
      }

    }
  }
  public struct LedgerKeyStats: XDRCodable {
    public var accountID: AccountID
    public var ext: LedgerKeyStatsExt

    public init(
        accountID: AccountID,
        ext: LedgerKeyStatsExt) {

      self.accountID = accountID
      self.ext = ext
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.accountID.toXDR())
      xdr.append(self.ext.toXDR())

      return xdr
    }

    public init(xdrData: inout Data) throws {
      self.accountID = try AccountID(xdrData: &xdrData)
      self.ext = try LedgerKeyStatsExt(xdrData: &xdrData)
    }

    public enum LedgerKeyStatsExt: XDRDiscriminatedUnion {
      case emptyVersion

      public var discriminant: Int32 {
        switch self {
        case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
        }
      }

      public func toXDR() -> Data {
        var xdr = Data()

        xdr.append(self.discriminant.toXDR())

        switch self {
        case .emptyVersion: xdr.append(Data())
        }

        return xdr
      }

      public init(xdrData: inout Data) throws {
        let discriminant = try Int32(xdrData: &xdrData)

        switch discriminant {
        case LedgerVersion.emptyVersion.rawValue: self = .emptyVersion
        default:
          throw XDRErrors.unknownEnumCase
        }
      }

    }
  }
  public struct LedgerKeyAccountLimits: XDRCodable {
    public var accountID: AccountID
    public var ext: LedgerKeyAccountLimitsExt

    public init(
        accountID: AccountID,
        ext: LedgerKeyAccountLimitsExt) {

      self.accountID = accountID
      self.ext = ext
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.accountID.toXDR())
      xdr.append(self.ext.toXDR())

      return xdr
    }

    public init(xdrData: inout Data) throws {
      self.accountID = try AccountID(xdrData: &xdrData)
      self.ext = try LedgerKeyAccountLimitsExt(xdrData: &xdrData)
    }

    public enum LedgerKeyAccountLimitsExt: XDRDiscriminatedUnion {
      case emptyVersion

      public var discriminant: Int32 {
        switch self {
        case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
        }
      }

      public func toXDR() -> Data {
        var xdr = Data()

        xdr.append(self.discriminant.toXDR())

        switch self {
        case .emptyVersion: xdr.append(Data())
        }

        return xdr
      }

      public init(xdrData: inout Data) throws {
        let discriminant = try Int32(xdrData: &xdrData)

        switch discriminant {
        case LedgerVersion.emptyVersion.rawValue: self = .emptyVersion
        default:
          throw XDRErrors.unknownEnumCase
        }
      }

    }
  }
  public struct LedgerKeyAssetPair: XDRCodable {
    public var base: AssetCode
    public var quote: AssetCode
    public var ext: LedgerKeyAssetPairExt

    public init(
        base: AssetCode,
        quote: AssetCode,
        ext: LedgerKeyAssetPairExt) {

      self.base = base
      self.quote = quote
      self.ext = ext
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.base.toXDR())
      xdr.append(self.quote.toXDR())
      xdr.append(self.ext.toXDR())

      return xdr
    }

    public init(xdrData: inout Data) throws {
      self.base = try AssetCode(xdrData: &xdrData)
      self.quote = try AssetCode(xdrData: &xdrData)
      self.ext = try LedgerKeyAssetPairExt(xdrData: &xdrData)
    }

    public enum LedgerKeyAssetPairExt: XDRDiscriminatedUnion {
      case emptyVersion

      public var discriminant: Int32 {
        switch self {
        case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
        }
      }

      public func toXDR() -> Data {
        var xdr = Data()

        xdr.append(self.discriminant.toXDR())

        switch self {
        case .emptyVersion: xdr.append(Data())
        }

        return xdr
      }

      public init(xdrData: inout Data) throws {
        let discriminant = try Int32(xdrData: &xdrData)

        switch discriminant {
        case LedgerVersion.emptyVersion.rawValue: self = .emptyVersion
        default:
          throw XDRErrors.unknownEnumCase
        }
      }

    }
  }
  public struct LedgerKeyOffer: XDRCodable {
    public var offerID: Uint64
    public var ownerID: AccountID

    public init(
        offerID: Uint64,
        ownerID: AccountID) {

      self.offerID = offerID
      self.ownerID = ownerID
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.offerID.toXDR())
      xdr.append(self.ownerID.toXDR())

      return xdr
    }

    public init(xdrData: inout Data) throws {
      self.offerID = try Uint64(xdrData: &xdrData)
      self.ownerID = try AccountID(xdrData: &xdrData)
    }

  }
  public struct LedgerKeyReviewableRequest: XDRCodable {
    public var requestID: Uint64
    public var ext: LedgerKeyReviewableRequestExt

    public init(
        requestID: Uint64,
        ext: LedgerKeyReviewableRequestExt) {

      self.requestID = requestID
      self.ext = ext
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.requestID.toXDR())
      xdr.append(self.ext.toXDR())

      return xdr
    }

    public init(xdrData: inout Data) throws {
      self.requestID = try Uint64(xdrData: &xdrData)
      self.ext = try LedgerKeyReviewableRequestExt(xdrData: &xdrData)
    }

    public enum LedgerKeyReviewableRequestExt: XDRDiscriminatedUnion {
      case emptyVersion

      public var discriminant: Int32 {
        switch self {
        case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
        }
      }

      public func toXDR() -> Data {
        var xdr = Data()

        xdr.append(self.discriminant.toXDR())

        switch self {
        case .emptyVersion: xdr.append(Data())
        }

        return xdr
      }

      public init(xdrData: inout Data) throws {
        let discriminant = try Int32(xdrData: &xdrData)

        switch discriminant {
        case LedgerVersion.emptyVersion.rawValue: self = .emptyVersion
        default:
          throw XDRErrors.unknownEnumCase
        }
      }

    }
  }
  public struct LedgerKeyExternalSystemAccountID: XDRCodable {
    public var accountID: AccountID
    public var externalSystemType: Int32
    public var ext: LedgerKeyExternalSystemAccountIDExt

    public init(
        accountID: AccountID,
        externalSystemType: Int32,
        ext: LedgerKeyExternalSystemAccountIDExt) {

      self.accountID = accountID
      self.externalSystemType = externalSystemType
      self.ext = ext
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.accountID.toXDR())
      xdr.append(self.externalSystemType.toXDR())
      xdr.append(self.ext.toXDR())

      return xdr
    }

    public init(xdrData: inout Data) throws {
      self.accountID = try AccountID(xdrData: &xdrData)
      self.externalSystemType = try Int32(xdrData: &xdrData)
      self.ext = try LedgerKeyExternalSystemAccountIDExt(xdrData: &xdrData)
    }

    public enum LedgerKeyExternalSystemAccountIDExt: XDRDiscriminatedUnion {
      case emptyVersion

      public var discriminant: Int32 {
        switch self {
        case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
        }
      }

      public func toXDR() -> Data {
        var xdr = Data()

        xdr.append(self.discriminant.toXDR())

        switch self {
        case .emptyVersion: xdr.append(Data())
        }

        return xdr
      }

      public init(xdrData: inout Data) throws {
        let discriminant = try Int32(xdrData: &xdrData)

        switch discriminant {
        case LedgerVersion.emptyVersion.rawValue: self = .emptyVersion
        default:
          throw XDRErrors.unknownEnumCase
        }
      }

    }
  }
  public struct LedgerKeySale: XDRCodable {
    public var saleID: Uint64
    public var ext: LedgerKeySaleExt

    public init(
        saleID: Uint64,
        ext: LedgerKeySaleExt) {

      self.saleID = saleID
      self.ext = ext
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.saleID.toXDR())
      xdr.append(self.ext.toXDR())

      return xdr
    }

    public init(xdrData: inout Data) throws {
      self.saleID = try Uint64(xdrData: &xdrData)
      self.ext = try LedgerKeySaleExt(xdrData: &xdrData)
    }

    public enum LedgerKeySaleExt: XDRDiscriminatedUnion {
      case emptyVersion

      public var discriminant: Int32 {
        switch self {
        case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
        }
      }

      public func toXDR() -> Data {
        var xdr = Data()

        xdr.append(self.discriminant.toXDR())

        switch self {
        case .emptyVersion: xdr.append(Data())
        }

        return xdr
      }

      public init(xdrData: inout Data) throws {
        let discriminant = try Int32(xdrData: &xdrData)

        switch discriminant {
        case LedgerVersion.emptyVersion.rawValue: self = .emptyVersion
        default:
          throw XDRErrors.unknownEnumCase
        }
      }

    }
  }
  public struct LedgerKeyKeyValue: XDRCodable {
    public var key: Longstring
    public var ext: LedgerKeyKeyValueExt

    public init(
        key: Longstring,
        ext: LedgerKeyKeyValueExt) {

      self.key = key
      self.ext = ext
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.key.toXDR())
      xdr.append(self.ext.toXDR())

      return xdr
    }

    public init(xdrData: inout Data) throws {
      self.key = try Longstring(xdrData: &xdrData)
      self.ext = try LedgerKeyKeyValueExt(xdrData: &xdrData)
    }

    public enum LedgerKeyKeyValueExt: XDRDiscriminatedUnion {
      case emptyVersion

      public var discriminant: Int32 {
        switch self {
        case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
        }
      }

      public func toXDR() -> Data {
        var xdr = Data()

        xdr.append(self.discriminant.toXDR())

        switch self {
        case .emptyVersion: xdr.append(Data())
        }

        return xdr
      }

      public init(xdrData: inout Data) throws {
        let discriminant = try Int32(xdrData: &xdrData)

        switch discriminant {
        case LedgerVersion.emptyVersion.rawValue: self = .emptyVersion
        default:
          throw XDRErrors.unknownEnumCase
        }
      }

    }
  }
  public struct LedgerKeyAccountKYC: XDRCodable {
    public var accountID: AccountID
    public var ext: LedgerKeyAccountKYCExt

    public init(
        accountID: AccountID,
        ext: LedgerKeyAccountKYCExt) {

      self.accountID = accountID
      self.ext = ext
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.accountID.toXDR())
      xdr.append(self.ext.toXDR())

      return xdr
    }

    public init(xdrData: inout Data) throws {
      self.accountID = try AccountID(xdrData: &xdrData)
      self.ext = try LedgerKeyAccountKYCExt(xdrData: &xdrData)
    }

    public enum LedgerKeyAccountKYCExt: XDRDiscriminatedUnion {
      case emptyVersion

      public var discriminant: Int32 {
        switch self {
        case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
        }
      }

      public func toXDR() -> Data {
        var xdr = Data()

        xdr.append(self.discriminant.toXDR())

        switch self {
        case .emptyVersion: xdr.append(Data())
        }

        return xdr
      }

      public init(xdrData: inout Data) throws {
        let discriminant = try Int32(xdrData: &xdrData)

        switch discriminant {
        case LedgerVersion.emptyVersion.rawValue: self = .emptyVersion
        default:
          throw XDRErrors.unknownEnumCase
        }
      }

    }
  }
  public struct LedgerKeyExternalSystemAccountIDPoolEntry: XDRCodable {
    public var poolEntryID: Uint64
    public var ext: LedgerKeyExternalSystemAccountIDPoolEntryExt

    public init(
        poolEntryID: Uint64,
        ext: LedgerKeyExternalSystemAccountIDPoolEntryExt) {

      self.poolEntryID = poolEntryID
      self.ext = ext
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.poolEntryID.toXDR())
      xdr.append(self.ext.toXDR())

      return xdr
    }

    public init(xdrData: inout Data) throws {
      self.poolEntryID = try Uint64(xdrData: &xdrData)
      self.ext = try LedgerKeyExternalSystemAccountIDPoolEntryExt(xdrData: &xdrData)
    }

    public enum LedgerKeyExternalSystemAccountIDPoolEntryExt: XDRDiscriminatedUnion {
      case emptyVersion

      public var discriminant: Int32 {
        switch self {
        case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
        }
      }

      public func toXDR() -> Data {
        var xdr = Data()

        xdr.append(self.discriminant.toXDR())

        switch self {
        case .emptyVersion: xdr.append(Data())
        }

        return xdr
      }

      public init(xdrData: inout Data) throws {
        let discriminant = try Int32(xdrData: &xdrData)

        switch discriminant {
        case LedgerVersion.emptyVersion.rawValue: self = .emptyVersion
        default:
          throw XDRErrors.unknownEnumCase
        }
      }

    }
  }
  public struct LedgerKeyLimitsV2: XDRCodable {
    public var id: Uint64
    public var ext: LedgerKeyLimitsV2Ext

    public init(
        id: Uint64,
        ext: LedgerKeyLimitsV2Ext) {

      self.id = id
      self.ext = ext
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.id.toXDR())
      xdr.append(self.ext.toXDR())

      return xdr
    }

    public init(xdrData: inout Data) throws {
      self.id = try Uint64(xdrData: &xdrData)
      self.ext = try LedgerKeyLimitsV2Ext(xdrData: &xdrData)
    }

    public enum LedgerKeyLimitsV2Ext: XDRDiscriminatedUnion {
      case emptyVersion

      public var discriminant: Int32 {
        switch self {
        case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
        }
      }

      public func toXDR() -> Data {
        var xdr = Data()

        xdr.append(self.discriminant.toXDR())

        switch self {
        case .emptyVersion: xdr.append(Data())
        }

        return xdr
      }

      public init(xdrData: inout Data) throws {
        let discriminant = try Int32(xdrData: &xdrData)

        switch discriminant {
        case LedgerVersion.emptyVersion.rawValue: self = .emptyVersion
        default:
          throw XDRErrors.unknownEnumCase
        }
      }

    }
  }
  public struct LedgerKeyStatisticsV2: XDRCodable {
    public var id: Uint64
    public var ext: LedgerKeyStatisticsV2Ext

    public init(
        id: Uint64,
        ext: LedgerKeyStatisticsV2Ext) {

      self.id = id
      self.ext = ext
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.id.toXDR())
      xdr.append(self.ext.toXDR())

      return xdr
    }

    public init(xdrData: inout Data) throws {
      self.id = try Uint64(xdrData: &xdrData)
      self.ext = try LedgerKeyStatisticsV2Ext(xdrData: &xdrData)
    }

    public enum LedgerKeyStatisticsV2Ext: XDRDiscriminatedUnion {
      case emptyVersion

      public var discriminant: Int32 {
        switch self {
        case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
        }
      }

      public func toXDR() -> Data {
        var xdr = Data()

        xdr.append(self.discriminant.toXDR())

        switch self {
        case .emptyVersion: xdr.append(Data())
        }

        return xdr
      }

      public init(xdrData: inout Data) throws {
        let discriminant = try Int32(xdrData: &xdrData)

        switch discriminant {
        case LedgerVersion.emptyVersion.rawValue: self = .emptyVersion
        default:
          throw XDRErrors.unknownEnumCase
        }
      }

    }
  }
  public struct LedgerKeyPendingStatistics: XDRCodable {
    public var statisticsID: Uint64
    public var requestID: Uint64
    public var ext: LedgerKeyPendingStatisticsExt

    public init(
        statisticsID: Uint64,
        requestID: Uint64,
        ext: LedgerKeyPendingStatisticsExt) {

      self.statisticsID = statisticsID
      self.requestID = requestID
      self.ext = ext
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.statisticsID.toXDR())
      xdr.append(self.requestID.toXDR())
      xdr.append(self.ext.toXDR())

      return xdr
    }

    public init(xdrData: inout Data) throws {
      self.statisticsID = try Uint64(xdrData: &xdrData)
      self.requestID = try Uint64(xdrData: &xdrData)
      self.ext = try LedgerKeyPendingStatisticsExt(xdrData: &xdrData)
    }

    public enum LedgerKeyPendingStatisticsExt: XDRDiscriminatedUnion {
      case emptyVersion

      public var discriminant: Int32 {
        switch self {
        case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
        }
      }

      public func toXDR() -> Data {
        var xdr = Data()

        xdr.append(self.discriminant.toXDR())

        switch self {
        case .emptyVersion: xdr.append(Data())
        }

        return xdr
      }

      public init(xdrData: inout Data) throws {
        let discriminant = try Int32(xdrData: &xdrData)

        switch discriminant {
        case LedgerVersion.emptyVersion.rawValue: self = .emptyVersion
        default:
          throw XDRErrors.unknownEnumCase
        }
      }

    }
  }
  public struct LedgerKeyContract: XDRCodable {
    public var contractID: Uint64
    public var ext: LedgerKeyContractExt

    public init(
        contractID: Uint64,
        ext: LedgerKeyContractExt) {

      self.contractID = contractID
      self.ext = ext
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.contractID.toXDR())
      xdr.append(self.ext.toXDR())

      return xdr
    }

    public init(xdrData: inout Data) throws {
      self.contractID = try Uint64(xdrData: &xdrData)
      self.ext = try LedgerKeyContractExt(xdrData: &xdrData)
    }

    public enum LedgerKeyContractExt: XDRDiscriminatedUnion {
      case emptyVersion

      public var discriminant: Int32 {
        switch self {
        case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
        }
      }

      public func toXDR() -> Data {
        var xdr = Data()

        xdr.append(self.discriminant.toXDR())

        switch self {
        case .emptyVersion: xdr.append(Data())
        }

        return xdr
      }

      public init(xdrData: inout Data) throws {
        let discriminant = try Int32(xdrData: &xdrData)

        switch discriminant {
        case LedgerVersion.emptyVersion.rawValue: self = .emptyVersion
        default:
          throw XDRErrors.unknownEnumCase
        }
      }

    }
  }
  public struct LedgerKeyAtomicSwapAsk: XDRCodable {
    public var id: Uint64
    public var ext: LedgerKeyAtomicSwapAskExt

    public init(
        id: Uint64,
        ext: LedgerKeyAtomicSwapAskExt) {

      self.id = id
      self.ext = ext
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.id.toXDR())
      xdr.append(self.ext.toXDR())

      return xdr
    }

    public init(xdrData: inout Data) throws {
      self.id = try Uint64(xdrData: &xdrData)
      self.ext = try LedgerKeyAtomicSwapAskExt(xdrData: &xdrData)
    }

    public enum LedgerKeyAtomicSwapAskExt: XDRDiscriminatedUnion {
      case emptyVersion

      public var discriminant: Int32 {
        switch self {
        case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
        }
      }

      public func toXDR() -> Data {
        var xdr = Data()

        xdr.append(self.discriminant.toXDR())

        switch self {
        case .emptyVersion: xdr.append(Data())
        }

        return xdr
      }

      public init(xdrData: inout Data) throws {
        let discriminant = try Int32(xdrData: &xdrData)

        switch discriminant {
        case LedgerVersion.emptyVersion.rawValue: self = .emptyVersion
        default:
          throw XDRErrors.unknownEnumCase
        }
      }

    }
  }
  public struct LedgerKeyAccountRole: XDRCodable {
    public var id: Uint64
    public var ext: LedgerKeyAccountRoleExt

    public init(
        id: Uint64,
        ext: LedgerKeyAccountRoleExt) {

      self.id = id
      self.ext = ext
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.id.toXDR())
      xdr.append(self.ext.toXDR())

      return xdr
    }

    public init(xdrData: inout Data) throws {
      self.id = try Uint64(xdrData: &xdrData)
      self.ext = try LedgerKeyAccountRoleExt(xdrData: &xdrData)
    }

    public enum LedgerKeyAccountRoleExt: XDRDiscriminatedUnion {
      case emptyVersion

      public var discriminant: Int32 {
        switch self {
        case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
        }
      }

      public func toXDR() -> Data {
        var xdr = Data()

        xdr.append(self.discriminant.toXDR())

        switch self {
        case .emptyVersion: xdr.append(Data())
        }

        return xdr
      }

      public init(xdrData: inout Data) throws {
        let discriminant = try Int32(xdrData: &xdrData)

        switch discriminant {
        case LedgerVersion.emptyVersion.rawValue: self = .emptyVersion
        default:
          throw XDRErrors.unknownEnumCase
        }
      }

    }
  }
  public struct LedgerKeyAccountRule: XDRCodable {
    public var id: Uint64
    public var ext: LedgerKeyAccountRuleExt

    public init(
        id: Uint64,
        ext: LedgerKeyAccountRuleExt) {

      self.id = id
      self.ext = ext
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.id.toXDR())
      xdr.append(self.ext.toXDR())

      return xdr
    }

    public init(xdrData: inout Data) throws {
      self.id = try Uint64(xdrData: &xdrData)
      self.ext = try LedgerKeyAccountRuleExt(xdrData: &xdrData)
    }

    public enum LedgerKeyAccountRuleExt: XDRDiscriminatedUnion {
      case emptyVersion

      public var discriminant: Int32 {
        switch self {
        case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
        }
      }

      public func toXDR() -> Data {
        var xdr = Data()

        xdr.append(self.discriminant.toXDR())

        switch self {
        case .emptyVersion: xdr.append(Data())
        }

        return xdr
      }

      public init(xdrData: inout Data) throws {
        let discriminant = try Int32(xdrData: &xdrData)

        switch discriminant {
        case LedgerVersion.emptyVersion.rawValue: self = .emptyVersion
        default:
          throw XDRErrors.unknownEnumCase
        }
      }

    }
  }
  public struct LedgerKeySignerRole: XDRCodable {
    public var id: Uint64
    public var ext: LedgerKeySignerRoleExt

    public init(
        id: Uint64,
        ext: LedgerKeySignerRoleExt) {

      self.id = id
      self.ext = ext
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.id.toXDR())
      xdr.append(self.ext.toXDR())

      return xdr
    }

    public init(xdrData: inout Data) throws {
      self.id = try Uint64(xdrData: &xdrData)
      self.ext = try LedgerKeySignerRoleExt(xdrData: &xdrData)
    }

    public enum LedgerKeySignerRoleExt: XDRDiscriminatedUnion {
      case emptyVersion

      public var discriminant: Int32 {
        switch self {
        case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
        }
      }

      public func toXDR() -> Data {
        var xdr = Data()

        xdr.append(self.discriminant.toXDR())

        switch self {
        case .emptyVersion: xdr.append(Data())
        }

        return xdr
      }

      public init(xdrData: inout Data) throws {
        let discriminant = try Int32(xdrData: &xdrData)

        switch discriminant {
        case LedgerVersion.emptyVersion.rawValue: self = .emptyVersion
        default:
          throw XDRErrors.unknownEnumCase
        }
      }

    }
  }
  public struct LedgerKeySignerRule: XDRCodable {
    public var id: Uint64
    public var ext: LedgerKeySignerRuleExt

    public init(
        id: Uint64,
        ext: LedgerKeySignerRuleExt) {

      self.id = id
      self.ext = ext
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.id.toXDR())
      xdr.append(self.ext.toXDR())

      return xdr
    }

    public init(xdrData: inout Data) throws {
      self.id = try Uint64(xdrData: &xdrData)
      self.ext = try LedgerKeySignerRuleExt(xdrData: &xdrData)
    }

    public enum LedgerKeySignerRuleExt: XDRDiscriminatedUnion {
      case emptyVersion

      public var discriminant: Int32 {
        switch self {
        case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
        }
      }

      public func toXDR() -> Data {
        var xdr = Data()

        xdr.append(self.discriminant.toXDR())

        switch self {
        case .emptyVersion: xdr.append(Data())
        }

        return xdr
      }

      public init(xdrData: inout Data) throws {
        let discriminant = try Int32(xdrData: &xdrData)

        switch discriminant {
        case LedgerVersion.emptyVersion.rawValue: self = .emptyVersion
        default:
          throw XDRErrors.unknownEnumCase
        }
      }

    }
  }
  public struct LedgerKeyStamp: XDRCodable {
    public var ledgerHash: Hash
    public var licenseHash: Hash
    public var ext: LedgerKeyStampExt

    public init(
        ledgerHash: Hash,
        licenseHash: Hash,
        ext: LedgerKeyStampExt) {

      self.ledgerHash = ledgerHash
      self.licenseHash = licenseHash
      self.ext = ext
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.ledgerHash.toXDR())
      xdr.append(self.licenseHash.toXDR())
      xdr.append(self.ext.toXDR())

      return xdr
    }

    public init(xdrData: inout Data) throws {
      self.ledgerHash = try Hash(xdrData: &xdrData)
      self.licenseHash = try Hash(xdrData: &xdrData)
      self.ext = try LedgerKeyStampExt(xdrData: &xdrData)
    }

    public enum LedgerKeyStampExt: XDRDiscriminatedUnion {
      case emptyVersion

      public var discriminant: Int32 {
        switch self {
        case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
        }
      }

      public func toXDR() -> Data {
        var xdr = Data()

        xdr.append(self.discriminant.toXDR())

        switch self {
        case .emptyVersion: xdr.append(Data())
        }

        return xdr
      }

      public init(xdrData: inout Data) throws {
        let discriminant = try Int32(xdrData: &xdrData)

        switch discriminant {
        case LedgerVersion.emptyVersion.rawValue: self = .emptyVersion
        default:
          throw XDRErrors.unknownEnumCase
        }
      }

    }
  }
  public struct LedgerKeyLicense: XDRCodable {
    public var licenseHash: Hash
    public var ext: LedgerKeyLicenseExt

    public init(
        licenseHash: Hash,
        ext: LedgerKeyLicenseExt) {

      self.licenseHash = licenseHash
      self.ext = ext
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.licenseHash.toXDR())
      xdr.append(self.ext.toXDR())

      return xdr
    }

    public init(xdrData: inout Data) throws {
      self.licenseHash = try Hash(xdrData: &xdrData)
      self.ext = try LedgerKeyLicenseExt(xdrData: &xdrData)
    }

    public enum LedgerKeyLicenseExt: XDRDiscriminatedUnion {
      case emptyVersion

      public var discriminant: Int32 {
        switch self {
        case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
        }
      }

      public func toXDR() -> Data {
        var xdr = Data()

        xdr.append(self.discriminant.toXDR())

        switch self {
        case .emptyVersion: xdr.append(Data())
        }

        return xdr
      }

      public init(xdrData: inout Data) throws {
        let discriminant = try Int32(xdrData: &xdrData)

        switch discriminant {
        case LedgerVersion.emptyVersion.rawValue: self = .emptyVersion
        default:
          throw XDRErrors.unknownEnumCase
        }
      }

    }
  }
  public struct LedgerKeyPoll: XDRCodable {
    public var id: Uint64
    public var ext: EmptyExt

    public init(
        id: Uint64,
        ext: EmptyExt) {

      self.id = id
      self.ext = ext
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.id.toXDR())
      xdr.append(self.ext.toXDR())

      return xdr
    }

    public init(xdrData: inout Data) throws {
      self.id = try Uint64(xdrData: &xdrData)
      self.ext = try EmptyExt(xdrData: &xdrData)
    }

  }
  public struct LedgerKeyVote: XDRCodable {
    public var pollID: Uint64
    public var voterID: AccountID
    public var ext: EmptyExt

    public init(
        pollID: Uint64,
        voterID: AccountID,
        ext: EmptyExt) {

      self.pollID = pollID
      self.voterID = voterID
      self.ext = ext
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.pollID.toXDR())
      xdr.append(self.voterID.toXDR())
      xdr.append(self.ext.toXDR())

      return xdr
    }

    public init(xdrData: inout Data) throws {
      self.pollID = try Uint64(xdrData: &xdrData)
      self.voterID = try AccountID(xdrData: &xdrData)
      self.ext = try EmptyExt(xdrData: &xdrData)
    }

  }
  public struct LedgerKeyAccountSpecificRule: XDRCodable {
    public var id: Uint64
    public var ext: EmptyExt

    public init(
        id: Uint64,
        ext: EmptyExt) {

      self.id = id
      self.ext = ext
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.id.toXDR())
      xdr.append(self.ext.toXDR())

      return xdr
    }

    public init(xdrData: inout Data) throws {
      self.id = try Uint64(xdrData: &xdrData)
      self.ext = try EmptyExt(xdrData: &xdrData)
    }

  }
  public struct LedgerKeySwap: XDRCodable {
    public var id: Uint64
    public var ext: EmptyExt

    public init(
        id: Uint64,
        ext: EmptyExt) {

      self.id = id
      self.ext = ext
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.id.toXDR())
      xdr.append(self.ext.toXDR())

      return xdr
    }

    public init(xdrData: inout Data) throws {
      self.id = try Uint64(xdrData: &xdrData)
      self.ext = try EmptyExt(xdrData: &xdrData)
    }

  }
  public struct LedgerKeyData: XDRCodable {
    public var id: Uint64
    public var ext: EmptyExt

    public init(
        id: Uint64,
        ext: EmptyExt) {

      self.id = id
      self.ext = ext
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.id.toXDR())
      xdr.append(self.ext.toXDR())

      return xdr
    }

    public init(xdrData: inout Data) throws {
      self.id = try Uint64(xdrData: &xdrData)
      self.ext = try EmptyExt(xdrData: &xdrData)
    }

  }
  public struct LedgerKeyDeferredPayment: XDRCodable {
    public var id: Uint64
    public var ext: EmptyExt

    public init(
        id: Uint64,
        ext: EmptyExt) {

      self.id = id
      self.ext = ext
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.id.toXDR())
      xdr.append(self.ext.toXDR())

      return xdr
    }

    public init(xdrData: inout Data) throws {
      self.id = try Uint64(xdrData: &xdrData)
      self.ext = try EmptyExt(xdrData: &xdrData)
    }

  }
  public struct LedgerKeyLiquidityPool: XDRCodable {
    public var id: Uint64
    public var ext: EmptyExt

    public init(
        id: Uint64,
        ext: EmptyExt) {

      self.id = id
      self.ext = ext
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.id.toXDR())
      xdr.append(self.ext.toXDR())

      return xdr
    }

    public init(xdrData: inout Data) throws {
      self.id = try Uint64(xdrData: &xdrData)
      self.ext = try EmptyExt(xdrData: &xdrData)
    }

  }
}
