// Automatically generated by xdrgen
// DO NOT EDIT or your changes may be overwritten

import Foundation

// === xdr source ============================================================

//  struct SCPStatement
//  {
//      NodeID nodeID;    // v
//      uint64 slotIndex; // i
//  
//      union switch (SCPStatementType type)
//      {
//      case PREPARE:
//          struct
//          {
//              Hash quorumSetHash;       // D
//              SCPBallot ballot;         // b
//              SCPBallot* prepared;      // p
//              SCPBallot* preparedPrime; // p'
//              uint32 nC;                // c.n
//              uint32 nH;                // h.n
//          } prepare;
//      case CONFIRM:
//          struct
//          {
//              SCPBallot ballot;   // b
//              uint32 nPrepared;   // p.n
//              uint32 nCommit;     // c.n
//              uint32 nH;          // h.n
//              Hash quorumSetHash; // D
//          } confirm;
//      case EXTERNALIZE:
//          struct
//          {
//              SCPBallot commit;         // c
//              uint32 nH;                // h.n
//              Hash commitQuorumSetHash; // D used before EXTERNALIZE
//          } externalize;
//      case NOMINATE:
//          SCPNomination nominate;
//      }
//      pledges;
//  };

//  ===========================================================================
public struct SCPStatement: XDRCodable {
  public var nodeID: NodeID
  public var slotIndex: Uint64
  public var pledges: SCPStatementPledges

  public init(
      nodeID: NodeID,
      slotIndex: Uint64,
      pledges: SCPStatementPledges) {

    self.nodeID = nodeID
    self.slotIndex = slotIndex
    self.pledges = pledges
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.nodeID.toXDR())
    xdr.append(self.slotIndex.toXDR())
    xdr.append(self.pledges.toXDR())

    return xdr
  }

  public init(xdrData: inout Data) throws {
    self.nodeID = try NodeID(xdrData: &xdrData)
    self.slotIndex = try Uint64(xdrData: &xdrData)
    self.pledges = try SCPStatementPledges(xdrData: &xdrData)
  }

  public enum SCPStatementPledges: XDRDiscriminatedUnion {
    case prepare(SCPStatementPrepare)
    case confirm(SCPStatementConfirm)
    case externalize(SCPStatementExternalize)
    case nominate(SCPNomination)

    public var discriminant: Int32 {
      switch self {
      case .prepare: return SCPStatementType.prepare.rawValue
      case .confirm: return SCPStatementType.confirm.rawValue
      case .externalize: return SCPStatementType.externalize.rawValue
      case .nominate: return SCPStatementType.nominate.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.discriminant.toXDR())

      switch self {
      case .prepare(let data): xdr.append(data.toXDR())
      case .confirm(let data): xdr.append(data.toXDR())
      case .externalize(let data): xdr.append(data.toXDR())
      case .nominate(let data): xdr.append(data.toXDR())
      }

      return xdr
    }

    public init(xdrData: inout Data) throws {
      let discriminant = try Int32(xdrData: &xdrData)

      switch discriminant {
      case SCPStatementType.prepare.rawValue:
        let data = try SCPStatementPrepare(xdrData: &xdrData)
        self = .prepare(data)
      case SCPStatementType.confirm.rawValue:
        let data = try SCPStatementConfirm(xdrData: &xdrData)
        self = .confirm(data)
      case SCPStatementType.externalize.rawValue:
        let data = try SCPStatementExternalize(xdrData: &xdrData)
        self = .externalize(data)
      case SCPStatementType.nominate.rawValue:
        let data = try SCPNomination(xdrData: &xdrData)
        self = .nominate(data)
      default:
        throw XDRErrors.unknownEnumCase
      }
    }

    public struct SCPStatementPrepare: XDRCodable {
      public var quorumSetHash: Hash
      public var ballot: SCPBallot
      public var prepared: SCPBallot?
      public var preparedPrime: SCPBallot?
      public var nC: Uint32
      public var nH: Uint32

      public init(
          quorumSetHash: Hash,
          ballot: SCPBallot,
          prepared: SCPBallot?,
          preparedPrime: SCPBallot?,
          nC: Uint32,
          nH: Uint32) {

        self.quorumSetHash = quorumSetHash
        self.ballot = ballot
        self.prepared = prepared
        self.preparedPrime = preparedPrime
        self.nC = nC
        self.nH = nH
      }

      public func toXDR() -> Data {
        var xdr = Data()

        xdr.append(self.quorumSetHash.toXDR())
        xdr.append(self.ballot.toXDR())
        xdr.append(self.prepared.toXDR())
        xdr.append(self.preparedPrime.toXDR())
        xdr.append(self.nC.toXDR())
        xdr.append(self.nH.toXDR())

        return xdr
      }

      public init(xdrData: inout Data) throws {
        self.quorumSetHash = try Hash(xdrData: &xdrData)
        self.ballot = try SCPBallot(xdrData: &xdrData)
        if (try Bool(xdrData: &xdrData)) {
          self.prepared = try SCPBallot(xdrData: &xdrData)
        } else {
          self.prepared = nil
        }
        if (try Bool(xdrData: &xdrData)) {
          self.preparedPrime = try SCPBallot(xdrData: &xdrData)
        } else {
          self.preparedPrime = nil
        }
        self.nC = try Uint32(xdrData: &xdrData)
        self.nH = try Uint32(xdrData: &xdrData)
      }

    }
    public struct SCPStatementConfirm: XDRCodable {
      public var ballot: SCPBallot
      public var nPrepared: Uint32
      public var nCommit: Uint32
      public var nH: Uint32
      public var quorumSetHash: Hash

      public init(
          ballot: SCPBallot,
          nPrepared: Uint32,
          nCommit: Uint32,
          nH: Uint32,
          quorumSetHash: Hash) {

        self.ballot = ballot
        self.nPrepared = nPrepared
        self.nCommit = nCommit
        self.nH = nH
        self.quorumSetHash = quorumSetHash
      }

      public func toXDR() -> Data {
        var xdr = Data()

        xdr.append(self.ballot.toXDR())
        xdr.append(self.nPrepared.toXDR())
        xdr.append(self.nCommit.toXDR())
        xdr.append(self.nH.toXDR())
        xdr.append(self.quorumSetHash.toXDR())

        return xdr
      }

      public init(xdrData: inout Data) throws {
        self.ballot = try SCPBallot(xdrData: &xdrData)
        self.nPrepared = try Uint32(xdrData: &xdrData)
        self.nCommit = try Uint32(xdrData: &xdrData)
        self.nH = try Uint32(xdrData: &xdrData)
        self.quorumSetHash = try Hash(xdrData: &xdrData)
      }

    }
    public struct SCPStatementExternalize: XDRCodable {
      public var commit: SCPBallot
      public var nH: Uint32
      public var commitQuorumSetHash: Hash

      public init(
          commit: SCPBallot,
          nH: Uint32,
          commitQuorumSetHash: Hash) {

        self.commit = commit
        self.nH = nH
        self.commitQuorumSetHash = commitQuorumSetHash
      }

      public func toXDR() -> Data {
        var xdr = Data()

        xdr.append(self.commit.toXDR())
        xdr.append(self.nH.toXDR())
        xdr.append(self.commitQuorumSetHash.toXDR())

        return xdr
      }

      public init(xdrData: inout Data) throws {
        self.commit = try SCPBallot(xdrData: &xdrData)
        self.nH = try Uint32(xdrData: &xdrData)
        self.commitQuorumSetHash = try Hash(xdrData: &xdrData)
      }

    }
  }
}
