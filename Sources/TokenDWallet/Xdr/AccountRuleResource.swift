// Automatically generated by xdrgen
// DO NOT EDIT or your changes may be overwritten

import Foundation

// === xdr source ============================================================

//  //: Describes properties of some entries that can be used to restrict the usage of entries
//  union AccountRuleResource switch (LedgerEntryType type)
//  {
//  case ASSET:
//      //: Describes properties that are equal to managed asset entry fields
//      struct
//      {
//          AssetCode assetCode;
//          uint64 assetType;
//  
//          EmptyExt ext;
//      } asset;
//  case REVIEWABLE_REQUEST:
//      //: Describes properties that are equal to managed reviewable request entry fields
//      struct
//      {
//          //: Describes properties of some reviewable request types that
//          //: can be used to restrict the usage of reviewable requests
//          ReviewableRequestResource details;
//  
//          //: reserved for future extension
//          EmptyExt ext;
//      } reviewableRequest;
//  case ANY:
//      void;
//  case OFFER_ENTRY:
//      //: Describes properties that are equal to managed offer entry fields and their properties
//      struct
//      {
//          //: type of base asset
//          uint64 baseAssetType;
//          //: type of quote asset
//          uint64 quoteAssetType;
//  
//          //: code of base asset
//          AssetCode baseAssetCode;
//          //: code of quote asset
//          AssetCode quoteAssetCode;
//  
//          bool isBuy;
//  
//          //: reserved for future extension
//          EmptyExt ext;
//      } offer;
//  case SALE:
//      //: Describes properties that are equal to managed offer entry fields
//      struct
//      {
//          uint64 saleID;
//          uint64 saleType;
//  
//          //: reserved for future extension
//          EmptyExt ext;
//      } sale;
//  case ATOMIC_SWAP_ASK:
//      struct
//      {
//          uint64 assetType;
//          AssetCode assetCode;
//  
//          EmptyExt ext;
//      } atomicSwapAsk;
//  case KEY_VALUE:
//      struct
//      {
//          //: prefix of key
//          longstring keyPrefix;
//  
//          //: reserved for future extension
//          EmptyExt ext;
//      } keyValue;
//  case POLL:
//      struct
//      {
//          //: ID of the poll
//          uint64 pollID;
//  
//          //: permission type of poll
//          uint32 permissionType;
//  
//          //: reserved for future extension
//          EmptyExt ext;
//      } poll;
//  case VOTE:
//      struct
//      {
//          //: ID of the poll
//          uint64 pollID;
//  
//          //: permission type of poll
//          uint32 permissionType;
//  
//          //: reserved for future extension
//          EmptyExt ext;
//      } vote;
//  case INITIATE_KYC_RECOVERY:
//      struct
//      {
//          //: Role id
//          uint64 roleID;
//  
//          //: reserved for future extension
//          EmptyExt ext;
//      } initiateKYCRecovery;
//  case ACCOUNT_SPECIFIC_RULE:
//      union switch(LedgerVersion v)
//      {
//      case EMPTY_VERSION:
//          void;
//      case ADD_ACC_SPECIFIC_RULE_RESOURCE:
//          struct
//          {
//              //: Describes properties of some ledger key that
//              //: can be used to restrict the usage of account specific rules
//              LedgerKey ledgerKey;
//  
//              //: reserved for future extension
//              EmptyExt ext;
//          } accountSpecificRule;
//      } accountSpecificRuleExt;
//  case SWAP:
//      struct
//      {
//          //: code of the asset
//          AssetCode assetCode;
//          //: type of asset
//          uint64 assetType;
//  
//          //: reserved for future extension
//          EmptyExt ext;
//      } swap;
//  case DATA:
//      struct
//      {
//          //: Numeric type of the data
//          uint64 type;
//          //: Reserved for future extension
//          EmptyExt ext;
//      } data;
//  case CUSTOM:
//      CustomRuleResource custom;
//  default:
//      //: reserved for future extension
//      EmptyExt ext;
//  };

//  ===========================================================================
public enum AccountRuleResource: XDRDiscriminatedUnion {
  case asset(AccountRuleResourceAsset)
  case reviewableRequest(AccountRuleResourceReviewableRequest)
  case any
  case offerEntry(AccountRuleResourceOffer)
  case sale(AccountRuleResourceSale)
  case atomicSwapAsk(AccountRuleResourceAtomicSwapAsk)
  case keyValue(AccountRuleResourceKeyValue)
  case poll(AccountRuleResourcePoll)
  case vote(AccountRuleResourceVote)
  case initiateKycRecovery(AccountRuleResourceInitiateKYCRecovery)
  case accountSpecificRule(AccountRuleResourceAccountSpecificRuleExt)
  case swap(AccountRuleResourceSwap)
  case data(AccountRuleResourceData)
  case custom(CustomRuleResource)

  public var discriminant: Int32 {
    switch self {
    case .asset: return LedgerEntryType.asset.rawValue
    case .reviewableRequest: return LedgerEntryType.reviewableRequest.rawValue
    case .any: return LedgerEntryType.any.rawValue
    case .offerEntry: return LedgerEntryType.offerEntry.rawValue
    case .sale: return LedgerEntryType.sale.rawValue
    case .atomicSwapAsk: return LedgerEntryType.atomicSwapAsk.rawValue
    case .keyValue: return LedgerEntryType.keyValue.rawValue
    case .poll: return LedgerEntryType.poll.rawValue
    case .vote: return LedgerEntryType.vote.rawValue
    case .initiateKycRecovery: return LedgerEntryType.initiateKycRecovery.rawValue
    case .accountSpecificRule: return LedgerEntryType.accountSpecificRule.rawValue
    case .swap: return LedgerEntryType.swap.rawValue
    case .data: return LedgerEntryType.data.rawValue
    case .custom: return LedgerEntryType.custom.rawValue
    }
  }

  public func toXDR() -> Data {
    var xdr = Data()

    xdr.append(self.discriminant.toXDR())

    switch self {
    case .asset(let data): xdr.append(data.toXDR())
    case .reviewableRequest(let data): xdr.append(data.toXDR())
    case .any: xdr.append(Data())
    case .offerEntry(let data): xdr.append(data.toXDR())
    case .sale(let data): xdr.append(data.toXDR())
    case .atomicSwapAsk(let data): xdr.append(data.toXDR())
    case .keyValue(let data): xdr.append(data.toXDR())
    case .poll(let data): xdr.append(data.toXDR())
    case .vote(let data): xdr.append(data.toXDR())
    case .initiateKycRecovery(let data): xdr.append(data.toXDR())
    case .accountSpecificRule(let data): xdr.append(data.toXDR())
    case .swap(let data): xdr.append(data.toXDR())
    case .data(let data): xdr.append(data.toXDR())
    case .custom(let data): xdr.append(data.toXDR())
    }

    return xdr
  }

  public init(xdrData: inout Data) throws {
    let discriminant = try Int32(xdrData: &xdrData)

    switch discriminant {
    case LedgerEntryType.asset.rawValue:
      let data = try AccountRuleResourceAsset(xdrData: &xdrData)
      self = .asset(data)
    case LedgerEntryType.reviewableRequest.rawValue:
      let data = try AccountRuleResourceReviewableRequest(xdrData: &xdrData)
      self = .reviewableRequest(data)
    case LedgerEntryType.any.rawValue: self = .any
    case LedgerEntryType.offerEntry.rawValue:
      let data = try AccountRuleResourceOffer(xdrData: &xdrData)
      self = .offerEntry(data)
    case LedgerEntryType.sale.rawValue:
      let data = try AccountRuleResourceSale(xdrData: &xdrData)
      self = .sale(data)
    case LedgerEntryType.atomicSwapAsk.rawValue:
      let data = try AccountRuleResourceAtomicSwapAsk(xdrData: &xdrData)
      self = .atomicSwapAsk(data)
    case LedgerEntryType.keyValue.rawValue:
      let data = try AccountRuleResourceKeyValue(xdrData: &xdrData)
      self = .keyValue(data)
    case LedgerEntryType.poll.rawValue:
      let data = try AccountRuleResourcePoll(xdrData: &xdrData)
      self = .poll(data)
    case LedgerEntryType.vote.rawValue:
      let data = try AccountRuleResourceVote(xdrData: &xdrData)
      self = .vote(data)
    case LedgerEntryType.initiateKycRecovery.rawValue:
      let data = try AccountRuleResourceInitiateKYCRecovery(xdrData: &xdrData)
      self = .initiateKycRecovery(data)
    case LedgerEntryType.accountSpecificRule.rawValue:
      let data = try AccountRuleResourceAccountSpecificRuleExt(xdrData: &xdrData)
      self = .accountSpecificRule(data)
    case LedgerEntryType.swap.rawValue:
      let data = try AccountRuleResourceSwap(xdrData: &xdrData)
      self = .swap(data)
    case LedgerEntryType.data.rawValue:
      let data = try AccountRuleResourceData(xdrData: &xdrData)
      self = .data(data)
    case LedgerEntryType.custom.rawValue:
      let data = try CustomRuleResource(xdrData: &xdrData)
      self = .custom(data)
    default:
      throw XDRErrors.unknownEnumCase
    }
  }
  public struct AccountRuleResourceAsset: XDRCodable {
    public var assetCode: AssetCode
    public var assetType: Uint64
    public var ext: EmptyExt

    public init(
        assetCode: AssetCode,
        assetType: Uint64,
        ext: EmptyExt) {

      self.assetCode = assetCode
      self.assetType = assetType
      self.ext = ext
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.assetCode.toXDR())
      xdr.append(self.assetType.toXDR())
      xdr.append(self.ext.toXDR())

      return xdr
    }

    public init(xdrData: inout Data) throws {
      self.assetCode = try AssetCode(xdrData: &xdrData)
      self.assetType = try Uint64(xdrData: &xdrData)
      self.ext = try EmptyExt(xdrData: &xdrData)
    }

  }
  public struct AccountRuleResourceReviewableRequest: XDRCodable {
    public var details: ReviewableRequestResource
    public var ext: EmptyExt

    public init(
        details: ReviewableRequestResource,
        ext: EmptyExt) {

      self.details = details
      self.ext = ext
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.details.toXDR())
      xdr.append(self.ext.toXDR())

      return xdr
    }

    public init(xdrData: inout Data) throws {
      self.details = try ReviewableRequestResource(xdrData: &xdrData)
      self.ext = try EmptyExt(xdrData: &xdrData)
    }

  }
  public struct AccountRuleResourceOffer: XDRCodable {
    public var baseAssetType: Uint64
    public var quoteAssetType: Uint64
    public var baseAssetCode: AssetCode
    public var quoteAssetCode: AssetCode
    public var isBuy: Bool
    public var ext: EmptyExt

    public init(
        baseAssetType: Uint64,
        quoteAssetType: Uint64,
        baseAssetCode: AssetCode,
        quoteAssetCode: AssetCode,
        isBuy: Bool,
        ext: EmptyExt) {

      self.baseAssetType = baseAssetType
      self.quoteAssetType = quoteAssetType
      self.baseAssetCode = baseAssetCode
      self.quoteAssetCode = quoteAssetCode
      self.isBuy = isBuy
      self.ext = ext
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.baseAssetType.toXDR())
      xdr.append(self.quoteAssetType.toXDR())
      xdr.append(self.baseAssetCode.toXDR())
      xdr.append(self.quoteAssetCode.toXDR())
      xdr.append(self.isBuy.toXDR())
      xdr.append(self.ext.toXDR())

      return xdr
    }

    public init(xdrData: inout Data) throws {
      self.baseAssetType = try Uint64(xdrData: &xdrData)
      self.quoteAssetType = try Uint64(xdrData: &xdrData)
      self.baseAssetCode = try AssetCode(xdrData: &xdrData)
      self.quoteAssetCode = try AssetCode(xdrData: &xdrData)
      self.isBuy = try Bool(xdrData: &xdrData)
      self.ext = try EmptyExt(xdrData: &xdrData)
    }

  }
  public struct AccountRuleResourceSale: XDRCodable {
    public var saleID: Uint64
    public var saleType: Uint64
    public var ext: EmptyExt

    public init(
        saleID: Uint64,
        saleType: Uint64,
        ext: EmptyExt) {

      self.saleID = saleID
      self.saleType = saleType
      self.ext = ext
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.saleID.toXDR())
      xdr.append(self.saleType.toXDR())
      xdr.append(self.ext.toXDR())

      return xdr
    }

    public init(xdrData: inout Data) throws {
      self.saleID = try Uint64(xdrData: &xdrData)
      self.saleType = try Uint64(xdrData: &xdrData)
      self.ext = try EmptyExt(xdrData: &xdrData)
    }

  }
  public struct AccountRuleResourceAtomicSwapAsk: XDRCodable {
    public var assetType: Uint64
    public var assetCode: AssetCode
    public var ext: EmptyExt

    public init(
        assetType: Uint64,
        assetCode: AssetCode,
        ext: EmptyExt) {

      self.assetType = assetType
      self.assetCode = assetCode
      self.ext = ext
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.assetType.toXDR())
      xdr.append(self.assetCode.toXDR())
      xdr.append(self.ext.toXDR())

      return xdr
    }

    public init(xdrData: inout Data) throws {
      self.assetType = try Uint64(xdrData: &xdrData)
      self.assetCode = try AssetCode(xdrData: &xdrData)
      self.ext = try EmptyExt(xdrData: &xdrData)
    }

  }
  public struct AccountRuleResourceKeyValue: XDRCodable {
    public var keyPrefix: Longstring
    public var ext: EmptyExt

    public init(
        keyPrefix: Longstring,
        ext: EmptyExt) {

      self.keyPrefix = keyPrefix
      self.ext = ext
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.keyPrefix.toXDR())
      xdr.append(self.ext.toXDR())

      return xdr
    }

    public init(xdrData: inout Data) throws {
      self.keyPrefix = try Longstring(xdrData: &xdrData)
      self.ext = try EmptyExt(xdrData: &xdrData)
    }

  }
  public struct AccountRuleResourcePoll: XDRCodable {
    public var pollID: Uint64
    public var permissionType: Uint32
    public var ext: EmptyExt

    public init(
        pollID: Uint64,
        permissionType: Uint32,
        ext: EmptyExt) {

      self.pollID = pollID
      self.permissionType = permissionType
      self.ext = ext
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.pollID.toXDR())
      xdr.append(self.permissionType.toXDR())
      xdr.append(self.ext.toXDR())

      return xdr
    }

    public init(xdrData: inout Data) throws {
      self.pollID = try Uint64(xdrData: &xdrData)
      self.permissionType = try Uint32(xdrData: &xdrData)
      self.ext = try EmptyExt(xdrData: &xdrData)
    }

  }
  public struct AccountRuleResourceVote: XDRCodable {
    public var pollID: Uint64
    public var permissionType: Uint32
    public var ext: EmptyExt

    public init(
        pollID: Uint64,
        permissionType: Uint32,
        ext: EmptyExt) {

      self.pollID = pollID
      self.permissionType = permissionType
      self.ext = ext
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.pollID.toXDR())
      xdr.append(self.permissionType.toXDR())
      xdr.append(self.ext.toXDR())

      return xdr
    }

    public init(xdrData: inout Data) throws {
      self.pollID = try Uint64(xdrData: &xdrData)
      self.permissionType = try Uint32(xdrData: &xdrData)
      self.ext = try EmptyExt(xdrData: &xdrData)
    }

  }
  public struct AccountRuleResourceInitiateKYCRecovery: XDRCodable {
    public var roleID: Uint64
    public var ext: EmptyExt

    public init(
        roleID: Uint64,
        ext: EmptyExt) {

      self.roleID = roleID
      self.ext = ext
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.roleID.toXDR())
      xdr.append(self.ext.toXDR())

      return xdr
    }

    public init(xdrData: inout Data) throws {
      self.roleID = try Uint64(xdrData: &xdrData)
      self.ext = try EmptyExt(xdrData: &xdrData)
    }

  }
  public enum AccountRuleResourceAccountSpecificRuleExt: XDRDiscriminatedUnion {
    case emptyVersion
    case addAccSpecificRuleResource(AccountRuleResourceAccountSpecificRuleExtAccountSpecificRule)

    public var discriminant: Int32 {
      switch self {
      case .emptyVersion: return LedgerVersion.emptyVersion.rawValue
      case .addAccSpecificRuleResource: return LedgerVersion.addAccSpecificRuleResource.rawValue
      }
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.discriminant.toXDR())

      switch self {
      case .emptyVersion: xdr.append(Data())
      case .addAccSpecificRuleResource(let data): xdr.append(data.toXDR())
      }

      return xdr
    }

    public init(xdrData: inout Data) throws {
      let discriminant = try Int32(xdrData: &xdrData)

      switch discriminant {
      case LedgerVersion.emptyVersion.rawValue: self = .emptyVersion
      case LedgerVersion.addAccSpecificRuleResource.rawValue:
        let data = try AccountRuleResourceAccountSpecificRuleExtAccountSpecificRule(xdrData: &xdrData)
        self = .addAccSpecificRuleResource(data)
      default:
        throw XDRErrors.unknownEnumCase
      }
    }

    public struct AccountRuleResourceAccountSpecificRuleExtAccountSpecificRule: XDRCodable {
      public var ledgerKey: LedgerKey
      public var ext: EmptyExt

      public init(
          ledgerKey: LedgerKey,
          ext: EmptyExt) {

        self.ledgerKey = ledgerKey
        self.ext = ext
      }

      public func toXDR() -> Data {
        var xdr = Data()

        xdr.append(self.ledgerKey.toXDR())
        xdr.append(self.ext.toXDR())

        return xdr
      }

      public init(xdrData: inout Data) throws {
        self.ledgerKey = try LedgerKey(xdrData: &xdrData)
        self.ext = try EmptyExt(xdrData: &xdrData)
      }

    }
  }
  public struct AccountRuleResourceSwap: XDRCodable {
    public var assetCode: AssetCode
    public var assetType: Uint64
    public var ext: EmptyExt

    public init(
        assetCode: AssetCode,
        assetType: Uint64,
        ext: EmptyExt) {

      self.assetCode = assetCode
      self.assetType = assetType
      self.ext = ext
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.assetCode.toXDR())
      xdr.append(self.assetType.toXDR())
      xdr.append(self.ext.toXDR())

      return xdr
    }

    public init(xdrData: inout Data) throws {
      self.assetCode = try AssetCode(xdrData: &xdrData)
      self.assetType = try Uint64(xdrData: &xdrData)
      self.ext = try EmptyExt(xdrData: &xdrData)
    }

  }
  public struct AccountRuleResourceData: XDRCodable {
    public var type: Uint64
    public var ext: EmptyExt

    public init(
        type: Uint64,
        ext: EmptyExt) {

      self.type = type
      self.ext = ext
    }

    public func toXDR() -> Data {
      var xdr = Data()

      xdr.append(self.type.toXDR())
      xdr.append(self.ext.toXDR())

      return xdr
    }

    public init(xdrData: inout Data) throws {
      self.type = try Uint64(xdrData: &xdrData)
      self.ext = try EmptyExt(xdrData: &xdrData)
    }

  }
}
